<questionbank group="Core Java">
	<category name="Basics">
		<qa id="1" rating="1">			<question><![CDATA[q:What do you understand by a variable?]]></question>
			<answer><![CDATA[Variable is a named memory location that can be easily referred in the program. The variable is used to hold the data and it can be changed during the course of the execution of the program. A variable is just a container for holding data and is accesible through a reference.]]></answer>
		</qa>
		<qa id="2" rating="2">			<question><![CDATA[q:What is the Java API?]]></question>
			<answer><![CDATA[The Java API(application programming interface) is a large collection of ready-made software components that provide many useful capabilities, such as graphical user interface (GUI) widgets, utility packages,etc.]]></answer>
		</qa>
		<qa id="3" rating="2
----">			<question><![CDATA[q:What if the main method is declared as private? What if the static modifier is removed from the signature of the main method? What if I do not provide the String array as the argument to the method?]]></question>
			<answer><![CDATA[1. The program compiles properly but at runtime it will give "Main method not public" error message. <br/>
  2. Program compiles.But at runtime throws an error "NoSuchMethodError"
  3. The program works fine without a string array as argument to main method.]]></answer>
		</qa>
		<qa id="4" rating="2">			<question><![CDATA[q:What is meant by pass by reference and pass by value in Java?]]></question>
			<answer><![CDATA[Pass by reference means, passing the address itself(like pointers) rather than passing the value. 
Pass by value means passing a copy of the value. Java uses pass by value.]]></answer>
		</qa>
		<qa id="5" rating="2">			<question><![CDATA[q:If you're overriding the method equals() of an object, which other method you might also consider?]]></question>
			<answer><![CDATA[hashCode()]]></answer>
		</qa>
		<qa id="6" rating="2">			<question><![CDATA[q:What is Byte Code?]]></question>
			<answer><![CDATA[All Java programs are compiled into class files that contain bytecodes. 
Bytecode is the intermediate representation of Java programs just as assembly code is the intermediate representation of C or C++ programs
These byte codes can be run in any platform and hence java is platform independent.]]></answer>
		</qa>
		<qa id="7" rating="1">			<question><![CDATA[q:Expain the reason for each keyword of public static void main(String args[])?]]></question>
			<answer><![CDATA[<b>public</b> main(..) is the first method called by java environment when a program is executed so it has to accessible from java environment. Hence the access specifier has to be public.<br/> 
    <b>static:</b> Java environment should be able to call this method without creating an instance of the class , so this method must be declared as static. <br/>
    <b>void:</b> main does not return anything so the return type must be void <br/>
    <b>String args[]</b> The argument String indicates the argument type which is given at the command line and <b>args</b> is an array for string given during command line. <br/>]]></answer>
		</qa>
		<qa id="8" rating="2">			<question><![CDATA[q:What are the differences between == and .equals()?
What would you use to compare two String variables - the operator == or the method equals()? 
How is it possible for two String objects with identical values not to be equal under the == operator?]]></question>
			<answer><![CDATA[The == operator compares two objects to determine if they are the same object in memory i.e. present in the same memory location. 
It is possible for two String objects to have the same value, but located in different areas of memory.
 == compares references while .equals compares contents. 
 The method public boolean equals(Object obj) is provided by the Object class and can be overridden. <br/>
 The default implementation returns true only if the object is compared with itself, which is equivalent to the equality operator == being 
 used to compare aliases to the object. String, BitSet, Date, and File override the equals() method. 
 For two String objects, value equality means that they contain the same character sequence. 
 For the Wrapper classes, value equality means that the primitive values are equal. 
<pre>public class EqualsTest {

	public static void main(String[] args) {

		String s1 = "abc";
		String s2 = s1;
		String s5 = "abc";
		String s3 = new String("abc");
		String s4 = new String("abc");
		System.out.println("== comparison : " + (s1 == s5));
		System.out.println("== comparison : " + (s1 == s2));
		System.out.println("Using equals method : " + s1.equals(s2));
		System.out.println("== comparison : " + s3 == s4);
		System.out.println("Using equals method : " + s3.equals(s4));
	}
}
<b>Output</b>
== comparison : true
== comparison : true
Using equals method : true
false
Using equals method : true
</pre>]]></answer>
		</qa>
		<qa id="9" rating="2">			<question><![CDATA[q:What is final, finalize() and finally? 
  What does it mean that a class or member is final?]]></question>
			<answer><![CDATA[<ul><li><b>final</b> - Variables defined in an interface are implicitly final. A final class can't be extended i.e., final class may not be subclassed. This is done for security reasons with basic classes like String and Integer. It also allows the compiler to make some optimizations, and makes thread safety a little easier to achieve. A final method can't be overridden when its class is inherited. You can't change value of a final variable (is a constant) </li>
   <li><b>finally</b> - a key word used in exception handling and will be executed whether or not an exception is thrown. For example, closing of open connections is done in the finally method. </li>
   <li><b>finalize</b> - helps in garbage collection. finalize() method is used just before an object is destroyed and garbage collected</li></ul>]]></answer>
		</qa>
		<qa id="10" rating="2">			<question><![CDATA[q:What is the GregorianCalendar,ResourceBundle,Locale class?]]></question>
			<answer><![CDATA[The GregorianCalendar provides support for traditional Western calendars. 
The ResourceBundle class is used to store locale-specific resources that can be loaded by a program to tailor the program's appearance to the particular locale in which it is being run.
The Locale class is used to tailor a program output to the conventions of a particular geographic, political, or cultural region.]]></answer>
		</qa>
		<qa id="11" rating="2">			<question><![CDATA[q:Why there are no global variables in Java?]]></question>
			<answer><![CDATA[Global variables are globally accessible. Java encapsulates data and makes it available through methods.]]></answer>
		</qa>
		<qa id="12" rating="1">			<question><![CDATA[q:How to convert String to Number in java program?]]></question>
			<answer><![CDATA[The valueOf() function of Integer class is is used to convert string to Number. Here is the code example: 
 String numString = "1000?; 
 int id=Integer.valueOf(numString).intValue();]]></answer>
		</qa>
		<qa id="13" rating="1">			<question><![CDATA[q:What is the difference between a while statement and a do statement?]]></question>
			<answer><![CDATA[A while statement (pre test) checks at the beginning of a loop to see whether the next loop iteration should occur. 
A do while statement (post test) checks at the end of a loop to see whether the next iteration of a loop should occur. 
The do statement will always execute the loop body at least once.]]></answer>
		</qa>
		<qa id="14" rating="1">			<question><![CDATA[q:Describe the principles of OOPS.]]></question>
			<answer><![CDATA[There are three main principals of oops which are called Polymorphism, Inheritance and Encapsulation.]]></answer>
		</qa>
		<qa id="15" rating="2">			<question><![CDATA[q:Explain the Inheritance principle.]]></question>
			<answer><![CDATA[Inheritance is the process by which one object acquires the properties of another object. Inheritance allows well-tested procedures 
to be reused and enables changes to make once and have effect in all relevant places.]]></answer>
		</qa>
		<qa id="16" rating="1">			<question><![CDATA[q:What do you understand by casting in java language? What are the types of casting?]]></question>
			<answer><![CDATA[The process of converting one data type to another is called Casting. There are two types of casting in Java; these are implicit casting and explicit casting.]]></answer>
		</qa>
		<qa id="17" rating="2">			<question><![CDATA[q:What is implicit and explicit casting?]]></question>
			<answer><![CDATA[Implicit casting is the process of simply assigning one entity to another without any transformation guidance to the compiler. This type of casting is not permitted in all kinds of transformations and may not work for all scenarios. 
Explicit casting in the process in which the complier are specifically informed about transforming the object.
Example 
 int i = 1000, k =100.20; 
 long j = i; //Implicit casting
 int j = (int) i; //Explicit casting]]></answer>
		</qa>
		<qa id="18" rating="2">			<question><![CDATA[q:What do you understand by downcasting?]]></question>
			<answer><![CDATA[The process of Downcasting refers to the casting from a general to a more specific type, i.e. casting down the hierarchy]]></answer>
		</qa>
		<qa id="19" rating="1">			<question><![CDATA[q:Is sizeof a keyword in java?]]></question>
			<answer><![CDATA[The sizeof operator is not a keyword.]]></answer>
		</qa>
		<qa id="20" rating="1">			<question><![CDATA[q:What is a native method?]]></question>
			<answer><![CDATA[A native method is a method that is implemented in a language other than Java.]]></answer>
		</qa>
		<qa id="21" rating="1">			<question><![CDATA[q:In System.out.println(), what is System, out and println?]]></question>
			<answer><![CDATA[System is a predefined final class, out is a PrintStream object and println is a built-in overloaded method in the out object.]]></answer>
		</qa>
		<qa id="22" rating="2">			<question><![CDATA[q:Explain Polymorphism. Explain the different forms of Polymorphism.]]></question>
			<answer><![CDATA[Polymorphism in simple terms means one name many forms. Polymorphism enables one entity to be used as a general category for different types of actions. The specific action is determined by the exact nature of the situation. 
Polymorphism gives us the ultimate flexibility in extensibility. The abiltiy to define more than pne function with the same name is called Polymorphism. In java there are two type of polymorphism: compile time polymorphism (overloading) and runtime polymorphism (overriding).

Polymorphism exists in three distinct forms in Java: 
 <ul><li> Method overloading </li>
 <li> Method overriding through inheritance </li>
 <li>Method overriding through the Java interface </li></ul>]]></answer>
		</qa>
		<qa id="23" rating="2">			<question><![CDATA[q:Explain Encapsulation.]]></question>
			<answer><![CDATA[Encapsulation is a process of binding or wrapping the data and the codes that operates on the data into a single entity. This keeps the data safe from outside interface and misuse. Objects allow procedures to be encapsulated with their data to reduce potential interference. One way to think about encapsulation is as a protective wrapper that prevents code and data from being arbitrarily accessed by other code defined outside the wrapper. 
Encapsulation may be used by creating 'get' and 'set' methods in a class (JAVABEAN) which are used to access the fields of the object. Typically the fields are made private while the get and set methods are public. 
Encapsulation can be used to validate the data that is to be stored, to do calculations on data that is stored in a field or fields, or for use in introspection (often the case when using javabeans in Struts, for instance).
Encapsulation is nothing but wrapping up the data and associated methods into a single unit in such a way that data can be accessed with the help of associated methods. 
Encapsulation provides data security. It is nothing but data hiding.]]></answer>
		</qa>
		<qa id="24" rating="2">			<question><![CDATA[q:What is the Java Virtual Machine (JVM),JRE, JDK?]]></question>
			<answer><![CDATA[The Java Virtual Machine is software that can be ported onto various hardware-based platforms .This manages the heap of objects and runtime stack.<br/>
The JRE is the Java Runtime Environment. The JRE consists of the Java Virtual Machine, the Java libraries, and all other components necessary to run Java applications and applets.<br/>
JDK contains software development tools which are used to compile and run the Java program.<br/>
Both JDK and JRE contains the JVM.JRE contains the runtime environment such as JVM and other Java classes (AWT, SWING), but does not contain any development tools such as a compiler or a debugger.]]></answer>
		</qa>
		<qa id="25" rating="2">			<question><![CDATA[q:What are Java Access modifiers? 
 What is the difference between public, private, protected and default Access Specifiers?]]></question>
			<answer><![CDATA[Access specifiers are keywords that determine the type of access to the member of a class. These keywords are for allowing 
 privileges to parts of a program such as functions and variables. These are: 
 <ul><li>Public : accessible to all classes </li>
 <li>Protected : accessible to the classes within the same package and any subclasses. </li>
 <li>Private : accessible only to the class to which they belong </li>
 <li>Default : accessible to the class to which they belong and to subclasses within the same package</li></ul>]]></answer>
		</qa>
		<qa id="26" rating="1">			<question><![CDATA[q:Which class is the superclass of every class?]]></question>
			<answer><![CDATA[Object.]]></answer>
		</qa>
		<qa id="27" rating="2">			<question><![CDATA[q:Name primitive Java types.]]></question>
			<answer><![CDATA[The 8 primitive types are byte, char, short, int, long, float, double, and boolean.]]></answer>
		</qa>
		<qa id="28" rating="2">			<question><![CDATA[q:What is the difference between static and non-static variables? What are class variables?What is static in java?What is a static method?]]></question>
			<answer><![CDATA[A static variable is associated with the class as a whole rather than with specific instances of a class. Each object will share a common copy of the static variables i.e. there is only one copy per class, no matter how many objects are created from it.<br/>
Class variables or static variables are declared with the static keyword in a class. These are declared outside a class and stored in static memory. Class variables are mostly used for constants. Static variables are always called by the class name. This variable is created when the program starts and gets destroyed when the programs stops.<br/>
The scope of the class variable is same an instance variable. Its initial value is same as instance variable and gets a default value when its not initialized corresponding to the data type. Similarly, a static method is a method that belongs to the class rather than any object of the class and doesn't apply to an object or even require that any objects of the class have been instantiated. <br/>
 Static methods are implicitly final, because overriding is done based on the type of the object, and static methods are attached to a class, not an object. A static method in a superclass can be shadowed by another static method in a subclass, as long as the original method was not declared final. However, you can't override a static method with a non-static method. In other words, you can't change a static method into an instance method in a subclass. <br/>
 Non-static variables take on unique values with each object instance.]]></answer>
		</qa>
		<qa id="29" rating="2">			<question><![CDATA[q:What is the difference between the boolean & operator and the && operator?]]></question>
			<answer><![CDATA[If an expression involving the boolean & operator is evaluated, both operands are evaluated, whereas the && operator is a short cut operator. When an expression involving the && operator is evaluated, the first operand is evaluated. If the first operand returns a value of true then the second operand is evaluated. If the first operand evaluates to false, the evaluation of the second operand is skipped.]]></answer>
		</qa>
		<qa id="30" rating="2">			<question><![CDATA[q:How does Java handle integer overflows and underflows?]]></question>
			<answer><![CDATA[It uses those low order bytes of the result that can fit into the size of the type allowed by the operation.]]></answer>
		</qa>
		<qa id="31" rating="1">			<question><![CDATA[q:What if I write static public void instead of public static void?]]></question>
			<answer><![CDATA[Program compiles and runs properly.]]></answer>
		</qa>
		<qa id="32" rating="1">			<question><![CDATA[q:What is the difference between declaring a variable and defining a variable?]]></question>
			<answer><![CDATA[In declaration we only mention the type of the variable and its name without initializing it. Defining means declaration + initialization.<br/>
E.g. String s; is just a declaration while String s = new String ("bob"); Or String s = "bob"; are both definitions.]]></answer>
		</qa>
		<qa id="33" rating="2">			<question><![CDATA[q:What type of parameter passing does Java support?]]></question>
			<answer><![CDATA[In Java the arguments (primitives and objects) are always passed by value. With objects, the object reference itself is passed by value and so both the original reference and parameter copy both refer to the same object.]]></answer>
		</qa>
		<qa id="34" rating="2">			<question><![CDATA[q:What do you understand by numeric promotion?]]></question>
			<answer><![CDATA[The Numeric promotion is the conversion of a smaller numeric type to a larger numeric type, so that integral and floating-point operations may take place. In the numerical promotion process the byte, char, and short values are converted to int values. The int values are also converted to long values, if necessary. The long and float values are converted to double values, as required.]]></answer>
		</qa>
		<qa id="35" rating="1">			<question><![CDATA[q:What is the first argument of the String array in main method? How can one prove that the array is not null but empty?]]></question>
			<answer><![CDATA[The String array is empty. It does not have any element. This is unlike C/C++ where the first element by default is the program name. If we do not provide any arguments on the command line, then the String array of main method will be empty but not null. 
 Print array.length. It will print 0. That means it is empty. But if it would have been null then it would have thrown a NullPointerException on attempting to print array.length.]]></answer>
		</qa>
		<qa id="36" rating="1">			<question><![CDATA[q:Can an application have multiple classes having main method?]]></question>
			<answer><![CDATA[Yes. While starting the application we mention the class name to be run. The JVM will look for the main method only in the class whose name you have mentioned. Hence there is not conflict amongst the multiple classes having main method.]]></answer>
		</qa>
		<qa id="37" rating="2">			<question><![CDATA[q:Can I have multiple main methods in the same class?]]></question>
			<answer><![CDATA[We can have multiple overloaded main methods but there can be only one main method with the following signature : 
public static void main(String[] args) {} 
  No the program fails to compile. The compiler says that the main method is already defined in the class.]]></answer>
		</qa>
		<qa id="38" rating="2">			<question><![CDATA[q:When is static variable loaded? Is it at compile time or runtime? When exactly a static block is loaded in Java?]]></question>
			<answer><![CDATA[Static variable are loaded when classloader brings the class to the JVM. It is not necessary that an object has to be created. Static variables will be allocated memory space when they have been loaded. The code in a static block is loaded/executed only once i.e. when the class is first initialized. A class can have any number of static blocks. Static block is not member of a class, they do not have a return statement and they cannot be called directly. Cannot contain this or super. They are primarily used to initialize static fields.]]></answer>
		</qa>
		<qa id="39" rating="1">			<question><![CDATA[q:Explain working of Java Virtual Machine (JVM)?]]></question>
			<answer><![CDATA[JVM is an abstract computing machine like any other real computing machine. JDK(javac) first converts .java file into .class file by using Compiler (.class is nothing but byte code file.) and Interpreter reads byte codes.]]></answer>
		</qa>
		<qa id="40" rating="2">			<question><![CDATA[q:How can I swap two variables without using a third variable?]]></question>
			<answer><![CDATA[Add two variables and assign the value into First variable. Subtract the Second value with the result Value. and assign to Second variable. Subtract the Result of First Variable With Result of Second Variable and Assign to First Variable. Example: 
<pre>
int a=5,b=10;
a=a+b; 
b=a-b; 
a=a-b;
An other approach to the same question <br/>
You use an XOR swap. 
 for example:   
 int a = 5; int b = 10; 
 a = a ^ b; 
 b = a ^ b; 
 a = a ^ b; 
 </pre>]]></answer>
		</qa>
		<qa id="41" rating="2">			<question><![CDATA[q:What is reflection API? How are they implemented?]]></question>
			<answer><![CDATA[Reflection is the process of introspecting the features and state of a class at runtime and dynamically manipulate at run time. 
This is supported using Reflection API with built-in classes like Class, Method, Fields, Constructors etc. 
Example: Using Java Reflection API we can get the class name, by using the getName method.]]></answer>
		</qa>
		<qa id="42" rating="2">			<question><![CDATA[q:Does JVM maintain a cache by itself? Does the JVM allocate objects in heap? Is this the OS heap or the heap maintained by the JVM? Why]]></question>
			<answer><![CDATA[Yes, the JVM maintains a cache by itself. It creates the Objects on the HEAP, but references to those objects are on the STACK.]]></answer>
		</qa>
		<qa id="43" rating="2">			<question><![CDATA[q:What is phantom memory?]]></question>
			<answer><![CDATA[Phantom memory is false memory. Memory that does not exist in reality.]]></answer>
		</qa>
		<qa id="44" rating="2">			<question><![CDATA[q:Can a method be static and synchronized?]]></question>
			<answer><![CDATA[A static method can be synchronized. If you do so, the JVM will obtain a lock on the java.lang.Class instance associated with the object. It is similar to saying: 
synchronized(XYZ.class) { 
}]]></answer>
		</qa>
		<qa id="45" rating="2">			<question><![CDATA[q:What is difference between String and StringTokenizer?]]></question>
			<answer><![CDATA[A StringTokenizer is utility class used to break up string. String is immutable while StringTokenizer is not
Example: 
 StringTokenizer st = new StringTokenizer("Hello World"); 
while (st.hasMoreTokens()) { 
  System.out.println(st.nextToken()); 
} 
 Output:Hello World]]></answer>
		</qa>
		<qa id="46" rating="3">			<question><![CDATA[q: Does java support multiple interitance? Why?]]></question>
			<answer><![CDATA[<pre>Java doesnt support multiple inheritance but it provide a way through which it can enact it. 
Consider the scenario is C++

Class A{
	public void add(){
	// some text
	}
}

Class B{

	public void add(){
	// some text
	}
}

Class C extends A,B{
	public static void main(String arg[]){

	C objC = new C();
	objC.add(); //	problem, compiler gets confused and cant
	decide to call Class A or B method.
}

This problem is called <b>Diamond problem</b>.

This problem in java is taken care with the use of interfaces

In Java similar problem would look like:

interface A{
	add();
}

interface B{
	add();
}

class C implements A,B{

	add(){
	// doesnt matter which interface it belong to
	}
}
</pre>]]></answer>
		</qa>
		<qa id="47" rating="3">			<question><![CDATA[q:What is difference between instanceof and isInstance(Object obj)?]]></question>
			<answer><![CDATA[<pre> Differences are as follows:

1) instanceof is a reserved word of Java, but isInstance(Object obj) is a method of java.lang.Class. 2) instanceof method is used to check the type of an object which are known at compile time and isInstance() could only be called on class, San instance of java.lang.Class. 
if (obj instanceof MyType) {
...
}else if (MyType.class.isInstance(obj)) {
...
}

3) instanceof is used of identify whether the object is type of a particular class or its subclass but isInstance(obj) is used to identify object of a particular class.</pre>]]></answer>
		</qa>
		<qa id="48" rating="3">			<question><![CDATA[q: Java supports pass by value or pass by reference?]]></question>
			<answer><![CDATA[<pre>Java supports only pass by value. The arguments passed as a parameter to a method is mainly primitive data types or objects. For the data type the actual value is passed.
Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references.Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects.Consider the example:
 public void tricky(Point arg1, Point arg2)
 {
   arg1.x = 100;
   arg1.y = 100;
   Point temp = arg1;
   arg1 = arg2;
   arg2 = temp;
 }
 public static void main(String [] args)
 {
   Point pnt1 = new Point(0,0);
   Point pnt2 = new Point(0,0);
   System.out.println("X: " + pnt1.x + " Y: " +pnt1.y); 
   System.out.println("X: " + pnt2.x + " Y: " +pnt2.y);
   System.out.println(" ");
   tricky(pnt1,pnt2);
   System.out.println("X: " + pnt1.x + " Y:" + pnt1.y); 
   System.out.println("X: " + pnt2.x + " Y: " +pnt2.y); 
 }

OutPut:
X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references.
</pre>]]></answer>
		</qa>
		<qa id="49" rating="2">			<question><![CDATA[q: What is memory leak?]]></question>
			<answer><![CDATA[A memory leak is where an unreferenced object that will never be used again still hangs around in memory and doesnt get garbage collected.]]></answer>
		</qa>
		<qa id="50" rating="3">			<question><![CDATA[q:How to find the size of an object?]]></question>
			<answer><![CDATA[The heap size of objects can be found using -

         Runtime.totalMemory()-Runtime.freeMemory() .]]></answer>
		</qa>
	</category>
	<category name="Classes and objects">
		<qa id="51" rating="2">			<question><![CDATA[q:What is the difference between an Interface and an Abstract class?]]></question>
			<answer><![CDATA[An abstract class can have instance methods that implement a default behavior. An Interface can only declare constants and instance methods, but cannot implement default behavior and all methods are implicitly abstract. An interface has all public members and no implementation. An abstract class is a class which may have the usual flavors of class members (private, protected, etc.), but has some abstract methods.]]></answer>
		</qa>
		<qa id="52" rating="2">			<question><![CDATA[q:  What restrictions are placed on method overloading?]]></question>
			<answer><![CDATA[Two methods may not have the same name and argument list but different return types.]]></answer>
		</qa>
		<qa id="53" rating="2">			<question><![CDATA[q:  What is the difference between String and StringBuffer?]]></question>
			<answer><![CDATA[String objects are immutable whereas StringBuffer objects are not. StringBuffer unlike Strings support growable and modifiable strings.]]></answer>
		</qa>
		<qa id="54" rating="2">			<question><![CDATA[q:  Can a private method of a superclass be declared within a subclass?]]></question>
			<answer><![CDATA[Sure. A private field or method or inner class belongs to its declared class and hides from its subclasses. 
 There is no way for private stuff to have a runtime overloading or overriding (polymorphism) features.]]></answer>
		</qa>
		<qa id="55" rating="1">			<question><![CDATA[q: What is the difference between a constructor and a method? How can a subclass call a method or a constructor defined in a superclass?]]></question>
			<answer><![CDATA[A constructor is a member function of a class that is used to create objects of that class, invoked using the new operator. It has the same name as the class and has no return type. They are only called once, whereas member functions can be called many times. A method is an ordinary member function of a class. It has its own name, a return type (which may be void), and is invoked using the dot operator. Constructor will be automatically invoked when an object is created whereas method has to be called explicitly. 
    super.method(); is used to call a super class method from a sub class. To call a constructor of the super class, we use the super(); statement as the first line of the subclass's constructor.]]></answer>
		</qa>
		<qa id="56" rating="2">			<question><![CDATA[q:  Can a top-level class be private or protected?]]></question>
			<answer><![CDATA[No. A top-level class cannot be private or protected. It can have either "public" or no modifier. If it does not have a modifier it is supposed to have a default access. If a top level class is declared as private/protected the compiler will complain that the "modifier private is not allowed here".]]></answer>
		</qa>
		<qa id="57" rating="2">			<question><![CDATA[q:  Why Java does not support multiple inheritance?]]></question>
			<answer><![CDATA[Java does support multiple inheritance via interface implementation. This is to avoid the Diamond problem?.]]></answer>
		</qa>
		<qa id="58" rating="2">			<question><![CDATA[q:  Where and how can you use a private constructor?]]></question>
			<answer><![CDATA[Private constructor can be used if you do not want any other class to instantiate the class. This concept is generally used in Singleton Design Pattern. The instantiation of such classes is done from a static public method.]]></answer>
		</qa>
		<qa id="59" rating="1">			<question><![CDATA[q:  How are this() and super() used with constructors?]]></question>
			<answer><![CDATA[this() is used to invoke a constructor of the same class. super() is used to invoke a superclass constructor.]]></answer>
		</qa>
		<qa id="60" rating="2">			<question><![CDATA[q:  What is Method Overriding? What restrictions are placed on method overriding?]]></question>
			<answer><![CDATA[When a class defines a method using the same name, return type, and argument list as that of a method in its superclass, the method in the subclass is said to override the method present in the Superclass. When the method is invoked for an object of the class, it is the new definition of the method that is called, and not the method definition from superclass. 
 Restrictions placed on method overriding 
 * Overridden methods must have the same name, argument list, and return type. 
 * The overriding method may not limit the access of the method it overrides. Methods may be overridden to be more public, not more private. 
 * The overriding method may not throw any exceptions that may not be thrown by the overridden method.]]></answer>
		</qa>
		<qa id="61" rating="2">			<question><![CDATA[q:  What are the Object and Class classes used for? Which class should you use to obtain design information about an object? 
Differentiate between a Class and an Object?]]></question>
			<answer><![CDATA[The Object class is the highest-level class in the Java class hierarchy. The Class class is used to represent the classes and interfaces that are loaded by a Java program. The Class class is used to obtain information about an object's design. A Class is only a definition or prototype of real life object. Whereas an object is an instance or living representation of real life object. Every object belongs to a class and every class contains one or more related objects.]]></answer>
		</qa>
		<qa id="62" rating="2">			<question><![CDATA[q: What is method overloading and method overriding?What is difference between overloading and overriding?]]></question>
			<answer><![CDATA[Method overloading: When 2 or more methods in a class have the same method names with different arguments, it is said to be method overloading. Overloading does not block inheritance from the superclass. Overloaded methods must have different method signatures but does not consider the return types.
  Method overriding : When a method in a class has the same method name with same arguments as that of the superclass, 
 it is said to be method overriding. Overriding blocks inheritance from the superclass. Overridden methods must have same signature. 
 Basically overloading and overriding are different aspects of polymorphism. 
 static/early binding polymorphism: overloading 
 dynamic/late binding polymorphism: overriding]]></answer>
		</qa>
		<qa id="63" rating="2">			<question><![CDATA[q:  If a class is declared without any access modifiers, where may the class be accessed?]]></question>
			<answer><![CDATA[A class that is declared without any access modifiers is said to have package or default access. This means that the class can only be accessed by other classes and interfaces that are defined within the same package.]]></answer>
		</qa>
		<qa id="64" rating="2">			<question><![CDATA[q: Explain protected and default access modifiers?]]></question>
			<answer><![CDATA[The protected modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.
For default - the class can only be accessed by other classes and interfaces that are defined within the same package.]]></answer>
		</qa>
		<qa id="65" rating="2">			<question><![CDATA[q:  Does a class inherit the constructors of its superclass?]]></question>
			<answer><![CDATA[A class does not inherit constructors from any of its super classes. However constructor chaining invokes the constructor in super class.]]></answer>
		</qa>
		<qa id="66" rating="2">			<question><![CDATA[q:  Which java.util classes and interfaces support event handling?]]></question>
			<answer><![CDATA[The EventObject class and the EventListener interface support event processing]]></answer>
		</qa>
		<qa id="67" rating="2">			<question><![CDATA[q:  Can an object's finalize() method be invoked while it is reachable?]]></question>
			<answer><![CDATA[An object's finalize() method cannot be invoked by the garbage collector while the object is still reachable. However, an object's finalize() method may be invoked by other objects.]]></answer>
		</qa>
		<qa id="68" rating="2">			<question><![CDATA[q:  What is the purpose of the Runtime class?]]></question>
			<answer><![CDATA[The purpose of the Runtime class is to provide access to the Java runtime system.]]></answer>
		</qa>
		<qa id="69" rating="2">			<question><![CDATA[q:  It returns the runtime information like memory availability.]]></question>
			<answer><![CDATA[* Runtime.freeMemory() -> Returns JVM Free Memory <br/>
   * Runtime.maxMemory() -> Returns the maximum amount of memory that the JVM will attempt to use. It also helps to run the garbage collector <br/>
   * Runtime.gc()<br/>]]></answer>
		</qa>
		<qa id="70" rating="2">			<question><![CDATA[q:  What is the purpose of the System class?]]></question>
			<answer><![CDATA[The purpose of the System class is to provide access to system resources.]]></answer>
		</qa>
		<qa id="71" rating="2">			<question><![CDATA[q:  Can an unreachable object become reachable again?]]></question>
			<answer><![CDATA[An unreachable object may become reachable again. This can happen when the object's finalize() method is invoked and the object performs an operation which causes it to become accessible to reachable object.]]></answer>
		</qa>
		<qa id="72" rating="2">			<question><![CDATA[q:  What is a bean? Where can it be used?]]></question>
			<answer><![CDATA[A Bean is a reusable and self-contained software component. Beans created using java take advantage of all the security and platform independent features of java. Bean can be plugged into any software application. Bean is a simple class which has set and get methods. It could be used within a JSP using JSP tags to use them.]]></answer>
		</qa>
		<qa id="73" rating="2">			<question><![CDATA[q:  What is the functionality of instanceOf() ?]]></question>
			<answer><![CDATA[instanceOf opertaor is used to check whether an object can be cast to a specific type without throwing ClassCastException.]]></answer>
		</qa>
		<qa id="74" rating="2">			<question><![CDATA[q: What would happen if you say this = null?]]></question>
			<answer><![CDATA[It will come up with Error Message 
"The left-hand side of an assignment must be a variable".]]></answer>
		</qa>
		<qa id="75" rating="2">			<question><![CDATA[q:  I want to create two instances of a class ,But when trying for creating third instance it should not allow me to create . What i have to do for making this?]]></question>
			<answer><![CDATA[<pre>One way of doing this would be: 
  public class test1 
{ 
  static int cntr=0; 
  test1() 
  { cntr++; 
  if(cntr>2) 
     throw new NullPointerException();//u can define a new exception // for this 
} 
 public static void main(String args[]) 
{ 
  test1 t1= new test1(); 
  System.out.println("hello 1?); 
  test1 t2= new test1(); 
  System.out.println("hello 2?); 
  test1 t3= new test1(); 
} </pre>]]></answer>
		</qa>
		<qa id="76" rating="2">			<question><![CDATA[q: What is the difference between an object and an instance?]]></question>
			<answer><![CDATA[An Object May not have a class definition. eg int a[] where a is an array. 
An Instance should have a class definition. 
  eg MyClass my=new MyClass(); 
my is an instance.]]></answer>
		</qa>
		<qa id="77" rating="2">			<question><![CDATA[q:  What is heap in Java?]]></question>
			<answer><![CDATA[It is a memory area which stores all the objects created by an executing program.]]></answer>
		</qa>
		<qa id="78" rating="2">			<question><![CDATA[q:  Why default constructor of base class will be called first in java?]]></question>
			<answer><![CDATA[A subclass inherits all the methods and fields (eligible one) from the base class, so base class is constructed in the process of creation of subclass object (subclass is also an object of superclass). Hence before initializing the default value of sub class the super class should be initialized using the default constructor.]]></answer>
		</qa>
		<qa id="79" rating="2">			<question><![CDATA[q:  What are the other ways to create an object other than creating as new object?]]></question>
			<answer><![CDATA[We can create object in different ways;<br/> 
  1.new operator <br/>
  2.class.forName: Classname obj = Class.forName("Fully Qualified class Name").newInstance(); <br/>
  3.newInstance <br/>
  4.object.clone <br/>]]></answer>
		</qa>
		<qa id="80" rating="2">			<question><![CDATA[q:  What is the difference between instance, object, reference and a class?]]></question>
			<answer><![CDATA[Class: A class is a user defined data type with set of data members & member functions <br/>
  Object: An Object is an instance of a class <br/>
  Reference: A reference is just like a pointer pointing to an object <br/>
  Instance: This represents the values of data members of a class at a particular time<br/>]]></answer>
		</qa>
		<qa id="81" rating="2">			<question><![CDATA[q:  Explain the user defined Exceptions?]]></question>
			<answer><![CDATA[User defined Exceptions are custom Exception classes defined by the user for specific purpose. A user defined exception can be created by simply sub-classing an Exception class or a subclass of an Exception class. This allows custom exceptions to be generated (using throw clause) and caught in the same way as normal exceptions. <br/><pre>
 Example: 
  class CustomException extends Exception { 
} </pre>]]></answer>
		</qa>
		<qa id="82" rating="2">			<question><![CDATA[q:  What classes of exceptions may be caught by a catch clause?]]></question>
			<answer><![CDATA[A catch clause can catch any exception that may be assigned to the Throwable type. This includes the Error and Exception types. Errors are generally irrecoverable conditions 
  Error's are irrecoverable exceptions. Usually a program terminates when an error is encountered.]]></answer>
		</qa>
		<qa id="83" rating="2">			<question><![CDATA[q: What is the difference between throw and throws keywords?]]></question>
			<answer><![CDATA[The throw keyword denotes a statement that causes an exception to be initiated. It takes the Exception object to be thrown as an argument. The exception will be caught by an enclosing try-catch block or propagated further up the calling hierarchy. The throws keyword is a modifier of a method that denotes that an exception may be thrown by the method. An exception can be rethrown.]]></answer>
		</qa>
		<qa id="84" rating="2">			<question><![CDATA[q: What class of exceptions are generated by the Java run-time system?]]></question>
			<answer><![CDATA[The Java runtime system generates Runtime Exceptions and Errors.]]></answer>
		</qa>
		<qa id="85" rating="2">			<question><![CDATA[q: What is the base class for Error and Exception?]]></question>
			<answer><![CDATA[Throwable]]></answer>
		</qa>
		<qa id="86" rating="2">			<question><![CDATA[q: What are Checked and Unchecked Exceptions?]]></question>
			<answer><![CDATA[A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses. Making an exception checked forces client programmers to deal with the exception may be thrown. Checked exceptions must be caught at compile time. Example: IOException. 
    Unchecked exceptions are RuntimeException and any of its subclasses. Class Error and its subclasses also are unchecked. With an unchecked exception, however, the compiler doesn't force client programmers either to catch the exception or declare it in a throws clause. In fact, client programmers may not even know that the exception could be thrown. Example: ArrayIndexOutOfBoundsException. Errors are often irrecoverable conditions.]]></answer>
		</qa>
		<qa id="87" rating="2">			<question><![CDATA[q: Does the code in finally block get executed if there is an exception and a return statement in a catch block? 
 What is the purpose of the finally clause of a try-catch-finally statement?]]></question>
			<answer><![CDATA[The finally clause is used to provide the capability to execute code no matter whether or not an exception is thrown or caught. If an exception occurs and there is a return statement in catch block, the finally block is still executed. The finally block will not be executed when the System.exit(0) statement is executed earlier or on system shut down earlier or the memory is used up earlier before the thread goes to finally block. 
<br/>
<pre>try{ 
 //some statements 
 } 
 catch{ 
 //statements when exception is caught 
 } 
 finally{ 
 //statements executed whether exception occurs or not 
 } 
</pre>]]></answer>
		</qa>
		<qa id="88" rating="2">			<question><![CDATA[q:  Does the order of placing catch statements matter in the catch block?]]></question>
			<answer><![CDATA[Yes, it does. The FileNoFoundException is inherited from the IOException. So FileNoFoundException is caught before IOException. Exception's subclasses have to be caught first before the General Exception]]></answer>
		</qa>
		<qa id="89" rating="2">			<question><![CDATA[q:  What is the difference between Abstract class and Interface. When should you use an abstract class, when an interface, when both?]]></question>
			<answer><![CDATA[<pre>1. Abstract class is a class which contain one or more abstract methods, which has to be implemented by sub classes. An abstract class can contain no abstract methods also i.e. abstract class may contain concrete methods. A Java Interface can contain only method declarations and public static final constants and doesn't contain their implementation. The classes which implement the Interface must provide the method definition for all the methods present. 
  3. Abstract classes are useful in a situation when some general methods should be implemented and specialization behavior should be implemented by subclasses. Interfaces are useful in a situation when all its properties need to be implemented by subclasses 
  4. All variables in an Interface are by default - public static final while an abstract class can have instance variables. 
  5. An interface is also used in situations when a class needs to extend an other class apart from the abstract class. In such situations its not possible to have multiple inheritance of classes. An interface on the other hand can be used when it is required to implement one or more interfaces. Abstract class does not support Multiple Inheritance whereas an Interface supports multiple Inheritance. 
  6. An Interface can only have public members whereas an abstract class can contain private as well as protected members. 
  7. A class implementing an interface must implement all of the methods defined in the interface, while a class extending an abstract class need not implement any of the methods defined in the abstract class. 
  8. The problem with an interface is, if you want to add a new feature (method) in its contract, then you MUST implement those method in all of the classes which implement that interface. However, in the case of an abstract class, the method can be simply implemented in the abstract class and the same can be called by its subclass 
  9. Interfaces are slow as it requires extra indirection to to find corresponding method in in the actual class. Abstract classes are fast 
 10.Interfaces are often used to describe the peripheral abilities of a class, and not its central identity, E.g. an Automobile class might 
 implement the Recyclable interface, which could apply to many otherwise totally unrelated objects. 
 Note: There is no difference between a fully abstract class (all methods declared as abstract and all fields are public static final) and an interface. 
 Note: If the various objects are all of-a-kind, and share a common state and behavior, then tend towards a common base class. If all they 
 share is a set of method signatures, then tend towards an interface. 
 Similarities: 
 Neither Abstract classes nor Interface can be instantiated. 
</pre>]]></answer>
		</qa>
		<qa id="90" rating="2">			<question><![CDATA[q: What does it mean that a method or class is abstract?]]></question>
			<answer><![CDATA[<pre>An abstract class cannot be instantiated. Only its subclasses can be instantiated. A class that has one or more abstract methods must be declared abstract. A subclass that does not provide an implementation for its inherited abstract methods must also be declared abstract. You indicate that a class is abstract with the abstract keyword like this: 
public abstract class AbstractClass 
  Abstract classes may contain abstract methods. A method declared abstract is not actually implemented in the class. It exists only to be overridden in subclasses.    Abstract methods may only be included in abstract classes. However, an abstract class is not required to have any abstract methods, though most of them do. Each subclass of an abstract class must override the abstract methods of its superclasses 
 or itself be declared abstract. Only the method's prototype is provided in the class definition. Also, a final method can not be abstract and vice versa. Methods specified in an interface are implicitly abstract.It has no body. 
 For example, 
:public abstract float getInfo() 
</pre>]]></answer>
		</qa>
		<qa id="91" rating="1">			<question><![CDATA[q:  What must a class do to implement an interface?]]></question>
			<answer><![CDATA[The class must provide all of the methods in the interface and identify the interface in its implements clause.]]></answer>
		</qa>
		<qa id="92" rating="2">			<question><![CDATA[q:  What is an abstract method?]]></question>
			<answer><![CDATA[An abstract method is a method whose implementation is deferred to a subclass.]]></answer>
		</qa>
		<qa id="93" rating="2">			<question><![CDATA[q:  What is interface? How to support multiple inhertance in Java? 
  What is a cloneable interface and how many methods does it contain?]]></question>
			<answer><![CDATA[<pre>An Interface are implicitly abstract and public. Interfaces with empty bodies are called marker interfaces having certain property or behavior. Examples:java.lang.Cloneable,java.io.Serializable,java.util.EventListener. An interface body can contain constant declarations, method prototype declarations, nested class declarations, and nested interface declarations. 
  Interfaces provide support for multiple inheritance in Java. A class that implements the interfaces is bound to implement all the methods defined in Interface. 
 Example of Interface: 
 public interface sampleInterface { 
 public void functionOne(); 
public long CONSTANT_ONE = 1000; 
 }
 </pre>]]></answer>
		</qa>
		<qa id="94" rating="2">			<question><![CDATA[q:  What is an abstract class? Can you make an instance of an abstract class?]]></question>
			<answer><![CDATA[<pre>Abstract classes can contain abstract and concrete methods. Abstract classes cannot be instantiated directly i.e. we cannot call the constructor of an abstract class directly nor we can create an instance of an abstract class by using "Class.forName().newInstance()" (Here we get java.lang.InstantiationException). However, if we create an instance of a class that extends an Abstract class, compiler will initialize both the classes. Here compiler will implicitly call the constructor of the Abstract class.

Any class that contain an abstract method must be declared "abstract" and abstract methods can have definitions only in child classes. By overriding and customizing the abstract methods in more than one subclass makes "Polymorphism" and through Inheritance we define body to the abstract methods. Basically an abstract class serves as a template. Abstract class must be extended/subclassed for it to be implemented. A class may be declared abstract even if it has no abstract methods. This prevents it from being instantiated. Abstract class is a class that provides some general functionality but leaves specific implementation to its inheriting classes. 
  Example of Abstract class: 
  abstract class AbstractClassExample{ 
  protected String name; 
 public String getname() { 
 return name; 
 } 
 public abstract void function(); 
 } 
 Example: Vehicle is an abstract class and Bus Truck, car etc are specific implementations 

  No! You cannot make an instance of an abstract class. An abstract class has to be sub-classed. 
 If you have an abstract class and you want to use a method which has been implemented, you may 
 need to subclass that abstract class, instantiate your subclass and then call that method. 
</pre>]]></answer>
		</qa>
		<qa id="95" rating="2">			<question><![CDATA[q: What is meant by "Abstract Interface"?]]></question>
			<answer><![CDATA[Firstly, an interface is abstract. That means you cannot have any implementation in an interface. 
 All the methods declared in an interface are abstract methods or signatures of the methods.]]></answer>
		</qa>
		<qa id="96" rating="2">			<question><![CDATA[q: How to define an Interface?]]></question>
			<answer><![CDATA[<pre>In Java Interface defines the methods but does not implement them. Interface can include constants. 
 A class that implements the interfaces is bound to implement all the methods defined in Interface. 
 Example of Interface: 
public interface SampleInterface { 
 public void functionOne(); 
 public long CONSTANT_ONE = 1000; 
 }
 </pre>]]></answer>
		</qa>
		<qa id="97" rating="2">			<question><![CDATA[q: Can Abstract Class have constructors? Can interfaces have constructors?]]></question>
			<answer><![CDATA[<pre>Abstract class's can have a constructor, but you cannot access it through the object, since you cannot instantiate abstract class. To access the constructor create a sub class and extend the abstract class which is having the constructor. 
Example 
 public abstract class AbstractExample { 
 public AbstractExample(){ 
 System.out.println("In AbstractExample()"); 
 } 
 } 
  public class Test extends AbstractExample{ 
 public static void main(String args[]){ 
 Test obj=new Test(); 
 } 
 } </pre>]]></answer>
		</qa>
		<qa id="98" rating="2">			<question><![CDATA[q: If interface & abstract class have same methods and those methods contain no implementation, which one would you prefer?]]></question>
			<answer><![CDATA[Obviously one should ideally go for an interface, as we can only extend one class. Implementing an interface for a class is very much effective rather than extending an abstract class because we can extend some other useful class for this subclass]]></answer>
		</qa>
		<qa id="99" rating="3">			<question><![CDATA[q:We encountered the dreaded java.lang.OutOfMemoryError PermGen space error.What does it mean ?]]></question>
			<answer><![CDATA[Permgen Space is the space where the class files are all loaded for the first time and there after they are loaded or referenced from there. This error means there is a hell lot of duplicate classes being loaded and not all are being unloaded. These duplicate class instances are cluttering the permgen space and resulting in this error. One expects only only class instance of a java file. This is basically a memory leak.]]></answer>
		</qa>
		<qa id="100" rating="3">			<question><![CDATA[q: Explain Association,Aggregation, Composition ?]]></question>
			<answer><![CDATA[<pre>
<b>Association is a</b> relationship between two classes. In this relationship the object of one instance perform an action on behalf of the other class. The typical beahiour can be invoking the method of other class and using the member of the other class.

public class MyMainClass{
public void init(){
new OtherClass.init();
}
}

<b>Aggregation has a</b> relationship between two classes. In this relationship the object of one class is a member of the other class. Aggregation always insists for a direction.

public class MyMainClass{
OtherClass otherClassObj = new OtherClass();
}

<b>Composition </b>is a special type of aggregation relationship with a difference that its the compulsion for the OtherClass object (in previous example) to exist for the existence of MyMainClass.
</pre>]]></answer>
		</qa>
		<qa id="101" rating="3">			<question><![CDATA[q:Explain HotSpot Java VM and its allocation?]]></question>
			<answer><![CDATA[For the HotSpot Java VM, the memory pools for serial garbage collection are the following.

<ul><li><b>Eden Space (heap)</b>: The pool from which memory is initially allocated for most objects.</li>
<li><b>Survivor Space (heap)</b>: The pool containing objects that have survived the garbage collection of the Eden space.</li>
<li><b>Tenured Generation (heap)</b>: The pool containing objects that have existed for some time in the survivor space.</li>
<li><b>Permanent Generation (non-heap)</b>: The pool containing all the reflective data of the virtual machine itself, such as class and method objects. With Java VMs that use class data sharing, this generation is divided into read-only and read-write areas.</li>
<li><b>Code Cache (non-heap)</b>: The HotSpot Java VM also includes a code cache, containing memory that is used for compilation and storage of native code.</li>
</ul>

<br/>Java uses generational garbage collection. This means that if you have an object foo (which is an instance of some class), the more garbage collection events it survives (if there are still references to it), the further it gets promoted. It starts in the young generation (which itself is divided into multiple spaces - Eden and Survivor) and would eventually end up in the tenured generation if it survived long enough]]></answer>
		</qa>
		<qa id="102" rating="2">			<question><![CDATA[q: What is an immutable class?]]></question>
			<answer><![CDATA[Immutable class is a class which once created, its contents can not be changed. Immutable objects are the objects whose state can not be changed once constructed. e.g. String class]]></answer>
		</qa>
		<qa id="103" rating="3">			<question><![CDATA[q: How to create an immutable class?]]></question>
			<answer><![CDATA[<pre> To create an immutable class following steps should be followed:
Create a final class.
Set the values of properties using constructor only.
Make the properties of the class final and private
Do not provide any setters for these properties.
If the instance fields include references to mutable objects, don't allow those objects to be changed:
Don't provide methods that modify the mutable objects.
Don't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.

E.g.
public final class FinalPersonClass {
      private final String name; 
      private final int age; 
      
      public FinalPersonClass(final String name, final int age) { 
            super(); 
            this.name = name; 
            this.age = age; 
      } 
      public int getAge() { 
            return age; 
      } 
      public String getName() { 
            return name; 
      } 
      
}</pre>]]></answer>
		</qa>
		<qa id="104" rating="2">			<question><![CDATA[q: Immutable objects are automatically thread-safe -true/false?]]></question>
			<answer><![CDATA[True. Since the state of the immutable objects can not be changed once they are created they are automatically synchronized/thread-safe.]]></answer>
		</qa>
		<qa id="105" rating="2">			<question><![CDATA[q: Which classes in java are immutable?]]></question>
			<answer><![CDATA[All wrapper classes in java.lang are immutable - 
String, Integer, Boolean, Character, Byte, Short, Long, Float, Double, BigDecimal, BigInteger]]></answer>
		</qa>
		<qa id="106" rating="2">			<question><![CDATA[q: What are the advantages of immutability?]]></question>
			<answer><![CDATA[<pre>  The advantages are: 
1) Immutable objects are automatically thread-safe, the overhead caused due to use of synchronisation is avoided.
2) Once created the state of the immutable object can not be changed so there is no possibility of them getting into an inconsistent state.
3) The references to the immutable objects can be easily shared or cached without having to copy or clone them as there state can not be changed ever after construction.
4) The best use of the immutable objects is as the keys of a map.
  </pre>]]></answer>
		</qa>
	</category>
	<category name="Cloning">
		<qa id="107" rating="2">			<question><![CDATA[q: What are different types of cloning in Java?]]></question>
			<answer><![CDATA[Java supports two type of cloning: - Deep and shallow cloning. By default shallow copy is used in Java. Object class has a method clone() which does shallow cloning.]]></answer>
		</qa>
		<qa id="108" rating="2">			<question><![CDATA[q: What is Shallow copy?]]></question>
			<answer><![CDATA[<pre>In shallow copy the object is copied without its contained objects.
Shallow clone only copies the top level structure of the object not the lower levels.
It is an exact bit copy of all the attributes.      

	obj -->containedObj1
	   \-->containedObj2		    

The shallow copy is done for obj and new object obj1 is created but contained objects of obj are not copied.

	obj -->containedObj1 <--obj1
	   \-->containedObj2 <--
	    
It can be seen that no new objects are created for obj1 and it is referring to the same old contained objects. If either of the containedObj contain any other object no new reference is created
</pre>]]></answer>
		</qa>
		<qa id="109" rating="3">			<question><![CDATA[q: What is deep copy and how it can be acheived?]]></question>
			<answer><![CDATA[<pre>In deep copy the object is copied along with the objects it refers to. Deep clone copies all the levels of the object from top to the bottom recursively.

	obj -->containedObj1
	   \-->containedObj2	
	    
When a deep copy of the object is done new references are created.

	obj -->containedObj1    containedObj3<--obj2
	   \-->containedObj2 	containedObj4<--/
	   
One solution is to simply implement your own custom method (e.g., deepCopy()) that returns a deep copy of an instance of one of your classes. This may be the best solution if you need a complex mixture of deep and shallow copies for different fields, but has a few significant drawbacks:
You must be able to modify the class (i.e., have the source code) or implement a subclass. If you have a third-party class for which you do not have the source and which is marked final, you are out of luck.

You must be able to access all of the fields of the classes superclasses. If significant parts of the objectes state are contained in private fields of a superclass, you will not be able to access them.
You must have a way to make copies of instances of all of the other kinds of objects that the object references. This is particularly problematic if the exact classes of referenced objects cannot be known until runtime.

Custom deep copy methods are tedious to implement, easy to get wrong, and difficult to maintain. The method must be revisited any time a change is made to the class or to any of its superclasses.

Other common solution to the deep copy problem is to use Java Object Serialization (JOS). The idea is simple: Write the object to an array using JOSes ObjectOutputStream and then use ObjectInputStream to reconsistute a copy of the object. The result will be a completely distinct object, with completely distinct referenced objects. JOS takes care of all of the details: superclass fields, following object graphs, and handling repeated references to the same object within the graph.
It will only work when the object being copied, as well as all of the other objects references directly or indirectly by the object, are serializable. (In other words, they must implement java.io.Serializable.) Fortunately it is often sufficient to simply declare that a given class implements java.io.Serializable and let Javaes default serialization mechanisms do their thing. Java Object Serialization is slow, and using it to make a deep copy requires both serializing and deserializing.
There are ways to speed it up (e.g., by pre-computing serial version ids and defining custom readObject() and writeObject() methods), but this will usually be the primary bottleneck. The byte array stream implementations included in the java.io package are designed to be general enough to perform reasonable well for data of different sizes and to be safe to use in a multi-threaded environment. These characteristics, however, slow down ByteArrayOutputStream and (to a lesser extent) ByteArrayInputStream .
</pre>]]></answer>
		</qa>
		<qa id="110" rating="2">			<question><![CDATA[q: What is difference between deep and shallow cloning?]]></question>
			<answer><![CDATA[<pre>The differences are as follows:
Consider the class:
	public class MyData{
		String id;
		Map myData;
	}
The shallow copying of this object will have new id object and values as  but will point to the myData of the original object. So a change in myData by either original or cloned object will be reflected in other also. But in deep copying there will be new id object and also new myData object and independent of original object but with same values.
Shallow copying is default cloning in Java which can be achieved using clone() method of Object class. For deep copying some extra logic need to be provided.</pre>]]></answer>
		</qa>
		<qa id="111" rating="2">			<question><![CDATA[q: What are the characteristics of a shallow clone?]]></question>
			<answer><![CDATA[<pre>If we do a = clone(b)
1) Then b.equals(a)
2) No method of a can modify the value of b.
</pre>]]></answer>
		</qa>
		<qa id="112" rating="2">			<question><![CDATA[q: What are the disadvantages of deep cloning?]]></question>
			<answer><![CDATA[<pre>Disadvantages of using Serialization to achieve deep cloning 
Serialization is more expensive than using object.clone().
Not all objects are serializable.
Serialization is not simple to implement for deep cloned object..
</pre>]]></answer>
		</qa>
	</category>
	<category name="Collections">
		<qa id="113" rating="1">			<question><![CDATA[q:What is the Collections API?]]></question>
			<answer><![CDATA[The Collections API is a set of classes and interfaces that support operations on collections of objects.]]></answer>
		</qa>
		<qa id="114" rating="1">			<question><![CDATA[q:What is the List,Vector,Iterator,Map,Set interface?]]></question>
			<answer><![CDATA[<pre>
The List interface provides support for ordered collections of objects. 	
The Vector class provides the capability to implement a growable array of objects. 	
The Iterator interface is used to step through the elements of a Collection . 	
The Map interface replaces the JDK 1.1 Dictionary class and is used associate keys with values.
The Set interface provides methods for accessing the elements of a finite mathematical set. Sets do not allow duplicate elements
</pre>]]></answer>
		</qa>
		<qa id="115" rating="2">			<question><![CDATA[q:Which java.util classes and interfaces support event handling?]]></question>
			<answer><![CDATA[The EventObject class and the EventListener interface support event processing.]]></answer>
		</qa>
		<qa id="116" rating="1">			<question><![CDATA[q:What is the Collection interface?]]></question>
			<answer><![CDATA[The Collection interface provides support for the implementation of a mathematical bag - an unordered collection of objects that may contain duplicates.
The Collections API is a set of classes and interfaces that support operations on collections of objects. 
 Example of classes: HashSet, HashMap, ArrayList, LinkedList, TreeSet and TreeMap. 
 Example of interfaces: Collection, Set, List and Map.]]></answer>
		</qa>
		<qa id="117" rating="2">			<question><![CDATA[q:What is the typical use of Hashtable?]]></question>
			<answer><![CDATA[Whenever a program wants to store a key value pair, one can use Hashtable.]]></answer>
		</qa>
		<qa id="118" rating="2">			<question><![CDATA[q:I am trying to store an object using a key in a Hashtable. And some other object already exists in that location, then what will happen? The existing object will be overwritten? Or the new object will be stored elsewhere?]]></question>
			<answer><![CDATA[The existing object will be overwritten and thus it will be lost.]]></answer>
		</qa>
		<qa id="119" rating="2">			<question><![CDATA[q:What is the difference between the size and capacity of a Vector?]]></question>
			<answer><![CDATA[The size is the number of elements actually stored in the vector, while capacity is the maximum number of elements it can store at a given instance of time.]]></answer>
		</qa>
		<qa id="120" rating="2">			<question><![CDATA[q:What is difference between ArrayList and vector?]]></question>
			<answer><![CDATA[<pre>
1) Synchronization - ArrayList is not thread-safe whereas Vector is thread-safe. In Vector class each method like add(), get(int i) is surrounded with a synchronized block and thus making Vector class thread-safe.

2) Data growth - Internally, both the ArrayList and Vector hold onto their contents using an Array. When an element is inserted into an ArrayList or a Vector, the object will need to expand its internal array if it runs out of room. A Vector defaults to doubling the size of its array, while the ArrayList increases its array size by 50 percent.
</pre>]]></answer>
		</qa>
		<qa id="121" rating="2">			<question><![CDATA[q:What is difference between HashMap and HashTable?]]></question>
			<answer><![CDATA[Both collections implements Map. Both collections store value as key-value pairs. The key differences between the two are
<pre>
1.Hashmap is not synchronized in nature but hshtable is.
2.Another difference is that iterator in the HashMap is fail-safe while the enumerator for the Hashtable isn't.
Fail-safe - if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException?
3.HashMap permits null values and only one null key, while Hashtable doesn't allow key or value as null.
</pre>]]></answer>
		</qa>
		<qa id="122" rating="2">			<question><![CDATA[q:When to use ArrayList or LinkedList ?]]></question>
			<answer><![CDATA[Adding new elements is pretty fast for either type of list. For the ArrayList, doing  random lookup using "get" is fast, but for LinkedList, it's slow. It's slow because there's no efficient way to index into the middle of a linked list. When removing elements, using ArrayList is slow. This is because all remaining elements in the underlying array of Object instances must be shifted down for each remove operation. But here LinkedList is fast, because deletion can be done simply by changing a couple of links. So an ArrayList works best for cases where you're doing random access on the list, and a LinkedList works better if you're doing a lot of editing in the middle of the list.]]></answer>
		</qa>
		<qa id="123" rating="3">			<question><![CDATA[q: Which design pattern Iterator follows?]]></question>
			<answer><![CDATA[It follows Iterator design pattern. Iterator Pattern is a type of behavioral pattern. The Iterator pattern is one, which allows you to navigate through a collection of data using a common interface without knowing about the underlying implementation. Iterator should be implemented as an interface. This allows the user to implement it anyway its easier for him/her to return data. The benefits of Iterator are about their strength to provide a common interface for iterating through collections without bothering about underlying implementation.<br/>

Example of Iteration design pattern - Enumeration The class java.util.Enumeration is an example of the Iterator pattern. It represents and abstract means of iterating over a collection of elements in some sequential order without the client having to know the representation of the collection being iterated over. It can be used to provide a uniform interface for traversing collections of all kinds.
</pre>]]></answer>
		</qa>
		<qa id="124" rating="1">			<question><![CDATA[q:Can a vector contain heterogenous objects?]]></question>
			<answer><![CDATA[Yes a Vector can contain heterogenous objects. Because a Vector stores everything in terms of Object.]]></answer>
		</qa>
		<qa id="125" rating="1">			<question><![CDATA[q:Can a ArrayList contain heterogenous objects?]]></question>
			<answer><![CDATA[Yes a ArrayList can contain heterogenous objects. Because a ArrayList stores everything in terms of Object.]]></answer>
		</qa>
		<qa id="126" rating="2">			<question><![CDATA[q:What is an enumeration?]]></question>
			<answer><![CDATA[An enumeration is an interface containing methods for accessing the underlying data structure from which the enumeration is obtained. It is a construct which collection classes return when you request a collection of all the objects stored in the collection. It allows sequential access to all the elements stored in the collection.]]></answer>
		</qa>
		<qa id="127" rating="2">			<question><![CDATA[q:Considering the basic properties of Vector and ArrayList, where will you use Vector and where will you use ArrayList?]]></question>
			<answer><![CDATA[The basic difference between a Vector and an ArrayList is that, vector is synchronized while ArrayList is not. Thus whenever there is a possibility of multiple threads accessing the same instance, one should use Vector. While if not multiple threads are going to access the same instance then use ArrayList. Non synchronized data structure will give better performance than the synchronized one.]]></answer>
		</qa>
		<qa id="128" rating="2">			<question><![CDATA[q:  What is HashMap and Map?]]></question>
			<answer><![CDATA[Map is Interface and Hashmap is class that implements this interface.]]></answer>
		</qa>
		<qa id="129" rating="2">			<question><![CDATA[q:  What is the significance of ListIterator? 
What is the difference b/w Iterator and ListIterator?]]></question>
			<answer><![CDATA[Iterator : Enables you to cycle through a collection in the forward direction only, for obtaining or removing elements<br/> 
 ListIterator : It extends Iterator, allow bidirectional traversal of list and the modification of elements]]></answer>
		</qa>
		<qa id="130" rating="2">			<question><![CDATA[q: Difference between HashMap and HashTable? Can we make hashmap synchronized?]]></question>
			<answer><![CDATA[Note on Some Important Terms 
<pre>
 1)Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released. 
 2)Fail-safe is relevant from the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object "structurally", a concurrent modification exception will be thrown. It is possible for other threads though to invoke "set" method since it doesn't modify the collection "structurally". However, if prior to calling "set", the collection has been modified structurally, "IllegalArgumentException" will be thrown. 
 
  HashMap can be synchronized by 
  Map m = Collections.synchronizeMap(hashMap); 
</pre>]]></answer>
		</qa>
		<qa id="131" rating="2">			<question><![CDATA[q:  What is the difference between set and list?]]></question>
			<answer><![CDATA[A Set stores elements in an unordered way and does not contain duplicate elements, whereas a list stores elements in an ordered way but may contain duplicate elements.]]></answer>
		</qa>
		<qa id="132" rating="2">			<question><![CDATA[q:  Difference between Vector and ArrayList? What is the Vector class?]]></question>
			<answer><![CDATA[Vector is synchronized whereas ArrayList is not. The Vector class provides the capability to implement a growable array of objects.<br/> ArrayList and Vector class both implement the List interface. Both classes are implemented using dynamically resizable arrays, providing fast random access and fast traversal. In vector the data is retrieved using the elementAt() method while in ArrayList, it is done using the get() method. <br/>ArrayList has no default size while vector has a default size of 10. when you want programs to run in multithreading environment then use concept of vector because it is synchronized. But ArrayList is not synchronized so, avoid use of it in a multithreading environment.]]></answer>
		</qa>
		<qa id="133" rating="2">			<question><![CDATA[q:  What is an Iterator interface? Is Iterator a Class or Interface? What is its use?]]></question>
			<answer><![CDATA[The Iterator is an interface, used to traverse through the elements of a Collection. It is not advisable to modify the collection itself while traversing an Iterator.]]></answer>
		</qa>
		<qa id="134" rating="2">			<question><![CDATA[q:  How can we access elements of a collection?]]></question>
			<answer><![CDATA[We can access the elements of a collection using the following ways: 
 1.Every collection object has get(index) method to get the element of the object. This method will return Object. 
 2.Collection provide Enumeration or Iterator object so that we can get the objects of a collection one by one.]]></answer>
		</qa>
		<qa id="135" rating="2">			<question><![CDATA[q:  What's the difference between a queue and a stack?]]></question>
			<answer><![CDATA[Stack is a data structure that is based on last-in-first-out rule (LIFO), while queues are based on First-in-first-out (FIFO) rule.]]></answer>
		</qa>
		<qa id="136" rating="2">			<question><![CDATA[q:  What is the Properties class?]]></question>
			<answer><![CDATA[The properties class is a subclass of Hashtable that can be read from or written to a stream. It also provides the capability to specify a set of default values to be used.]]></answer>
		</qa>
		<qa id="137" rating="2">			<question><![CDATA[q:  <pre>Which implementation of the List interface provides for the fastest insertion of a new element into the middle of the list? 
 a. Vector 
 b. ArrayList 
 c. LinkedList 
 d. None of the above </pre>]]></question>
			<answer><![CDATA[ArrayList and Vector both use an array to store the elements of the list. When an element is inserted into the middle of the list the elements that follow the insertion point must be shifted to make room for the new element.<br/>
The LinkedList is implemented using a doubly linked list; an insertion requires only the updating of the links at the point of insertion. Therefore, the LinkedList allows for fast insertions and deletions.]]></answer>
		</qa>
		<qa id="138" rating="2">			<question><![CDATA[q: How can we use hashset in collection interface?]]></question>
			<answer><![CDATA[This class implements the set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the Null element. 
This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets.]]></answer>
		</qa>
		<qa id="139" rating="2">			<question><![CDATA[q:  What are differences between Enumeration, ArrayList, Hashtable and Collections and Collection?]]></question>
			<answer><![CDATA[<pre>
Enumeration: It is series of elements. It can be use to enumerate through the elements of a vector, keys or values of a hashtable. You can not remove elements from Enumeration. 
  ArrayList: It is re-sizable array implementation. Belongs to 'List' group in collection. It permits all elements, including null. It is not thread -safe. 
  Hashtable: It maps key to value. You can use non-null value for key or value. It is part of group Map in collection. 
  Collections: It implements Polymorphic algorithms which operate on collections. 
  Collection: It is the root interface in the collection hierarchy. 
</pre>]]></answer>
		</qa>
		<qa id="140" rating="2">			<question><![CDATA[q:  What is difference between array & arraylist?]]></question>
			<answer><![CDATA[<pre>An ArrayList is resizable, where as, an array is not. ArrayList is a part of the Collection Framework. We can store any type of objects, and we can deal with only objects. It is growable. Array is collection of similar data items. We can have array of primitives or objects. It is of fixed size. We can have multi dimensional arrays. 
  Array: can store primitive ArrayList: Stores object only 
  Array: fix size ArrayList: resizable 
  Array: can have multi dimensional 
  Array: lang ArrayList: Collection framework 
  </pre>]]></answer>
		</qa>
		<qa id="141" rating="2">			<question><![CDATA[q:  Can you limit the initial capacity of vector in java?]]></question>
			<answer><![CDATA[Yes you can limit the initial capacity. We can construct an empty vector with specified initial capacity 
  public vector(int initialcapacity)]]></answer>
		</qa>
		<qa id="142" rating="2">			<question><![CDATA[q: What method should the key class of Hashmap override?]]></question>
			<answer><![CDATA[The methods to override are equals() and hashCode().]]></answer>
		</qa>
		<qa id="143" rating="2">			<question><![CDATA[q: What is the difference between Enumeration and Iterator?]]></question>
			<answer><![CDATA[The functionality of Enumeration interface is duplicated by the Iterator interface. Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects, where as using Iterator we can manipulate the objects also like adding and removing the objects. 
So Enumeration is used when ever we want to make Collection objects as Read-only.]]></answer>
		</qa>
		<qa id="144" rating="2">			<question><![CDATA[q:You need to insert huge amount of objects and randomly delete them one by one. Which Collection data structure is best bet?]]></question>
			<answer><![CDATA[LinkedList]]></answer>
		</qa>
		<qa id="145" rating="3">			<question><![CDATA[q: What goes wrong if the HashMap key has same hashCode value?]]></question>
			<answer><![CDATA[It leads to 'Collision' wherein all the values are stored in same bucket. Hence, the searching time increases quad radically.]]></answer>
		</qa>
		<qa id="146" rating="3">			<question><![CDATA[q: If hashCode() method is overridden but equals() is not, for the class 'A', then what may go wrong if you use this class as a key in HashMap?]]></question>
			<answer><![CDATA[<pre>
In Java, every object has access to the equals() method because it is inherited from the Object class. However, this default implementation just simply compares the memory addresses of the objects. You can override the default implementation of the equals() method defined in java.lang.Object. If you override the equals(), you MUST also override hashCode(). Otherwise a violation of the general contract for Object.hashCode will occur, which can have unexpected repercussions when your class is in conjunction with all hash-based collections.

Here is the contract, copied from the java.lang.Object specialization:

public int hashCode()
Returns a hash code value for the object. This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable.

The general contract of hashCode is:

<ul><li>Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</li>
<li>
If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</li>
<li>
It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.</li>
</ul>

As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)

The default implementation of equals() method checks to see if the two objects have the same identity. Similarly, the default implementation of the hashCode() method returns an integer based on the object's identity and is not based on the values of instance (and class) variables of the object. No matter how many times the values of its instance variables (data fields) change, the hash code calculated by the default hashCode implementation does not change during the life of the object.

Consider the following code, we have overridden equals() method to check if two objects are equal based on the values of their instance variables. Two objects may be stored at different memory addresses but may still be equal base on their instance variable.

public class CustomerID {
  private long crmID;
  private int nameSpace;

  public CustomerID(long crmID, int nameSpace) {
    super();
    this.crmID = crmID;
    this.nameSpace = nameSpace;
  }

  public boolean equals(Object obj) {
    //null instanceof Object will always return false
    if (!(obj instanceof CustomerID))
      return false;
    if (obj == this)
      return true;
    return  this.crmID == ((CustomerID) obj).crmID &&
            this.nameSpace == ((CustomerID) obj).nameSpace;
  }

  public static void main(String[] args) {
    Map m = new HashMap();
    m.put(new CustomerID(2345891234L,0),"Jeff Smith");
    System.out.println(m.get(new CustomerID(2345891234L,0)));
  }

}
Compile and run the above code, the output result is

null
What is wrong? The two instances of CustomerID are logically equal according to the class's equals method. Because the hashCode() method is not overridden, these two instances' identities are not in common to the default hashCode implementation. Therefore, the Object.hashCode returns two seemingly random numbers instead of two equal numbers. Such behavior violates "Equal objects must have equal hash codes" rule defined in the hashCode contract.

Let's provide a simple hashCode() method to fix this problem:

public class CustomerID {
  private long crmID;
  private int nameSpace;

  public CustomerID(long crmID, int nameSpace) {
    super();
    this.crmID = crmID;
    this.nameSpace = nameSpace;
  }

  public boolean equals(Object obj) {
    //null instanceof Object will always return false
    if (!(obj instanceof CustomerID))
      return false;
    if (obj == this)
      return true;
    return  this.crmID == ((CustomerID) obj).crmID &&
            this.nameSpace == ((CustomerID) obj).nameSpace;
  }

  public int hashCode() {
    int result = 0;
    result = (int)(crmID/12) + nameSpace;
    return result;
  }

  public static void main(String[] args) {
    Map m = new HashMap();
    m.put(new CustomerID(2345891234L,0),"Jeff Smith");
    System.out.println(m.get(new CustomerID(2345891234L,0)));
  }

}
Compile and run the above code, the output result is

Jeff Smith
The hashcode distribution for instances of a class should be random. This is exactly what is meant by the third provision of the hashCode contract. Write a correct hashCode method is easy, but to write an effective hashCode method is extremely difficult.

For example, From How to Avoid Traps and Correctly Override Methods From java.lang.Object: If you are unsure how to implement hashCode(), just always return 0 in your implementations. So all of your custom objects will return the same hash code. Yes, it turns hashtable of your objects into one (possibly) long linked-list, but you have implemented hashCode() correctly!

public int hashCode(){
  return 0;
}

It's legal because it ensures that equal objects have the same hash code, but it also indicates that every object has the same hash code. So every object will be hashed into the same bucket, and hash tables degenerate to linked lists. The performance is getting worse when it needs to process a large number of objects. How to implement a good hash function is a big topic and we will not cover here.
</pre>]]></answer>
		</qa>
		<qa id="147" rating="3">			<question><![CDATA[q: How will you remove duplicate element from a List?]]></question>
			<answer><![CDATA[Add the List elements to Set. Duplicates will be removed.]]></answer>
		</qa>
		<qa id="148" rating="2">			<question><![CDATA[q: How will you synchronize a Collection class dynamically?]]></question>
			<answer><![CDATA[Use the utility method]]></answer>
		</qa>
	</category>
	<category name="Exception">
		<qa id="149" rating="2">			<question><![CDATA[q:What is an Exception?]]></question>
			<answer><![CDATA[The exception is said to be thrown whenever an exceptional event occurs in java which signals that something is not correct with the code written and may give unexpected result. An exceptional event is a occurrence of condition which alters the normal program flow. Exceptional handler is the code that does something about the exception.]]></answer>
		</qa>
		<qa id="150" rating="2">			<question><![CDATA[q:Exceptions are defined in which java package?]]></question>
			<answer><![CDATA[All the exceptions are subclasses of java.lang.Exception]]></answer>
		</qa>
		<qa id="151" rating="2">			<question><![CDATA[q:How are the exceptions handled in java?]]></question>
			<answer><![CDATA[When an exception occurs the execution of the program is transferred to an appropriate exception handler.The try-catch-finally block is used to handle the exception.
The code in which the exception may occur is enclosed in a try block, also called as a guarded region.
The catch clause matches a specific exception to a block of code which handles that exception.
And the clean up code which needs to be executed no matter the exception occurs or not is put inside the finally block]]></answer>
		</qa>
		<qa id="152" rating="2">			<question><![CDATA[q:Explain the exception hierarchy in java.]]></question>
			<answer><![CDATA[Throwable is a parent class off all Exception classes. <br/>
They are two types of Exceptions: Checked exceptions and UncheckedExceptions. Both type of exceptions extends Exception class.]]></answer>
		</qa>
		<qa id="153" rating="2">			<question><![CDATA[q:What is Runtime Exception or unchecked exception?]]></question>
			<answer><![CDATA[Runtime exceptions represent problems that are the result of a programming problem. Such problems include arithmetic exceptions, such as dividing by zero; pointer exceptions, such as trying to access an object through a null reference; and indexing exceptions, such as attempting to access an array element through an index that is too large or too small. Runtime exceptions need not be explicitly caught in try catch block as it can occur anywhere in a program, and in a typical one they can be very numerous. Having to add runtime exceptions in every method declaration would reduce a program's clarity. Thus, the compiler does not require that you catch or specify runtime exceptions (although you can). The solution to rectify is to correct the programming logic where the exception has occurred or provide a check.]]></answer>
		</qa>
		<qa id="154" rating="2">			<question><![CDATA[q:What is checked exception?]]></question>
			<answer><![CDATA[Checked exception are the exceptions which forces the programmer to catch them explicitly in try-catch block. It is a subClass of Exception. Example: IOException.]]></answer>
		</qa>
		<qa id="155" rating="2">			<question><![CDATA[q:What is difference between Error and Exception?]]></question>
			<answer><![CDATA[An error is an irrecoverable condition occurring at runtime. Such as OutOfMemory error. These JVM errors and you can not repair them at runtime.Though error can be caught in catch block but the execution of application will come to a halt and is not recoverable.
While exceptions are conditions that occur because of bad input etc.<br/>
e.g. FileNotFoundException will be thrown if the specified file does not exist. Or a NullPointerException will take place if you try using a null reference. In most of the cases it is possible to recover from an exception (probably by giving user a feedback for entering proper values etc.)]]></answer>
		</qa>
		<qa id="156" rating="2">			<question><![CDATA[q:What is difference between ClassNotFoundException and NoClassDefFoundError?]]></question>
			<answer><![CDATA[A ClassNotFoundException is thrown when the reported class is not found by the ClassLoader in the CLASSPATH. It could also mean that the class in question is trying to be loaded from another class which was loaded in a parent classloader and hence the class from the child classloader is not visible.<br/>

Consider if NoClassDefFoundError occurs which is something like
java.lang.NoClassDefFoundError
src/com/TestClass
does not mean that the TestClass class is not in the CLASSPATH. It means that the class TestClass was found by the ClassLoader however when trying to load the class, it ran into an error reading the class definition. This typically happens when the class in question has static blocks or members which use a Class that's not found by the ClassLoader. So to find the culprit, view the source of the class in question (TestClass in this case) and look for code using static blocks or static members.]]></answer>
		</qa>
		<qa id="157" rating="2">			<question><![CDATA[q:What is throw keyword?]]></question>
			<answer><![CDATA[<pre>Throw keyword is used to throw the exception manually. It is mainly used when the program fails to satisfy the given condition and it wants to warn the application.The exception thrown should be subclass of Throwable.
 	public void parent(){
  try{
   child();
  }catch(MyCustomException e){	}
 	}

 	public void child{
  String iAmMandatory=null;
   if(iAmMandatory == null){
   	throw (new MyCustomException("Throwing exception using throw keyword");
  	}
 	}	
 </pre>]]></answer>
		</qa>
		<qa id="158" rating="2">			<question><![CDATA[q:What is use of throws keyword?]]></question>
			<answer><![CDATA[<pre>If the function is not capable of handling the exception then it can ask the calling method to handle it by simply putting the throws clause at the function declaration.
 	public void parent(){
  try{
   child();
  }catch(MyCustomException e){	}
 	}

 	public void child throws MyCustomException{
  	 //put some logic so that the exception occurs.
 	}</pre>]]></answer>
		</qa>
		<qa id="159" rating="2">			<question><![CDATA[q:What are the possible combination to write try, catch finally block?]]></question>
			<answer><![CDATA[<pre>
1) try{
//lines of code that may throw an exception
}catch(Exception e){
//lines of code to handle the exception thrown in try block
}finally{
//the clean code which is executed always no matter the exception occurs or not.
}

2 try{
}finally{}
3 try{
}catch(Exception e){
//lines of code to handle the exception thrown in try block
}

The catch blocks must always follow the try block.
If there are more than one catch blocks they all must follow each other without any block in between. 
The finally block must follow the catch block if one is present or if the catch block is absent the finally block must follow the try block.
</pre>]]></answer>
		</qa>
		<qa id="160" rating="2">			<question><![CDATA[q:How to create custom Exception?]]></question>
			<answer><![CDATA[<pre>To create you own exception extend the Exception class or any of its subclasses.
e.g.
1 class New1Exception extends Exception { } // this will create Checked Exception
2 class NewException extends IOExcpetion { } // this will create Checked exception
3 class NewException extends NullPonterExcpetion { } // this will create UnChecked exception</pre>]]></answer>
		</qa>
		<qa id="161" rating="2">			<question><![CDATA[q:When to make a custom checked Exception or custom unchecked Exception?]]></question>
			<answer><![CDATA[If an application can reasonably be expected to recover from an exception, make it a checked exception. If an application cannot do anything to recover from the exception, make it an unchecked exception.]]></answer>
		</qa>
		<qa id="162" rating="2">			<question><![CDATA[q:)What is StackOverflowError?]]></question>
			<answer><![CDATA[<pre>The StackOverFlowError is an Error Object thorwn by the Runtime System when it Encounters that your application/code has ran out of the memory. It may occur in case of recursive methods or a large amount of data is fetched from the server and stored in some object. This error is generated by JVM.
e.g. void swap(){
swap();
}</pre>]]></answer>
		</qa>
		<qa id="163" rating="2">			<question><![CDATA[q:Why did the designers decide to force a method to specify all uncaught checked exceptions that can be thrown within its scope?]]></question>
			<answer><![CDATA[Any Exception that can be thrown by a method is part of the method's public programming interface. Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them. These exceptions are as much a part of that method's programming interface as its parameters and return value.]]></answer>
		</qa>
		<qa id="164" rating="2">			<question><![CDATA[q:Once the control switches to the catch block does it return back to the try block to execute the balance code?]]></question>
			<answer><![CDATA[No. Once the control jumps to the catch block it never returns to the try block but it goes to finally block(if present).]]></answer>
		</qa>
		<qa id="165" rating="2">			<question><![CDATA[q:Where is the clean up code like release of resources is put in try-catch-finally block and why?]]></question>
			<answer><![CDATA[The code is put in a finally block because irrespective of try or catch block execution the control will flow to finally block. Typically finally block contains release of connections, closing of result set etc.]]></answer>
		</qa>
		<qa id="166" rating="2">			<question><![CDATA[q:Is it valid to have a try block without catch or finally?]]></question>
			<answer><![CDATA[<pre>NO. This will result in a compilation error. The try block must be followed by a catch or a finally block. It is legal to omit the either catch or the finally block but not both.
e.g. The following code is illegal.
try{
int i =0; 
}
int a = 2;
System.out.println("a = "+a);</pre>]]></answer>
		</qa>
		<qa id="167" rating="2">			<question><![CDATA[q:Is it valid to place some code in between try the catch/finally block that follows it?]]></question>
			<answer><![CDATA[<pre>No. There should not be any line of code present between the try and the catch/finally block. e.g. The following code is wrong.
try{}
String str = "ABC";
System.out.println("str = "+str);
catch(Exception e){}</pre>]]></answer>
		</qa>
		<qa id="168" rating="2">			<question><![CDATA[q:What happens if the exception is never caught and throws down the method stack?]]></question>
			<answer><![CDATA[If the exception is not caught by any of the method in the method's stack till you get to the main() method, the main method throws that exception and the JVM halts its execution.]]></answer>
		</qa>
		<qa id="169" rating="2">			<question><![CDATA[q:How do you get the descriptive information about the Exception occurred during the program execution?]]></question>
			<answer><![CDATA[All the exceptions inherit a method printStackTrace() from the Throwable class. This method prints the stack trace from where the exception occurred. It prints the most recently entered method first and continues down, printing the name of each method as it works its way down the call stack from the top.]]></answer>
		</qa>
		<qa id="170" rating="2">			<question><![CDATA[q:Can you catch more than one exceptions in a single catch block?]]></question>
			<answer><![CDATA[<pre>Yes. If the exception class specified in the catch clause has subclasses, any exception object that is a subclass of the specified Exception class will be caught by that single catch block.
E.g..
try {
// Some code here that can throw an IOException
}
catch (IOException e) {
e.printStackTrace();
}
The catch block above will catch IOException and all its subclasses e.g. FileNotFoundException etc.</pre>]]></answer>
		</qa>
		<qa id="171" rating="2">			<question><![CDATA[q:)Why is not considered as a good practice to write a single catchall handler to catch all the exceptions?]]></question>
			<answer><![CDATA[<pre>You can write a single catch block to handle all the exceptions thrown during the program execution as follows :
try {
// code that can throw exception of any possible type
}catch (Exception e) {
e.printStackTrace();
}
If you use the Superclass Exception in the catch block then you will not get the valuable information about each of the exception thrown during the execution, though you can find out the class of the exception occurred. Also it will reduce the readability of the code as the programmer will not understand what is the exact reason for putting the try-catch block.</pre>]]></answer>
		</qa>
		<qa id="172" rating="2">			<question><![CDATA[q:What is exception matching?]]></question>
			<answer><![CDATA[Exception matching is the process by which the the jvm finds out the matching catch block for the exception thrown from the list of catch blocks. When an exception is thrown, Java will try to find by looking at the available catch clauses in the top down manner. If it doesn't find one, it will search for a handler for a supertype of the exception. If it does not find a catch clause that matches a supertype for the exception, then the exception is propagated down the call stack. This process is called exception matching.]]></answer>
		</qa>
		<qa id="173" rating="2">			<question><![CDATA[q:What happens if the handlers for the most specific exceptions is placed above the more general exceptions handler?]]></question>
			<answer><![CDATA[<pre>Compilation fails. The catch block for handling the most specific exceptions must always be placed above the catch block written to handle the more general exceptions.
e.g. The code below will not compile.
1 try {
// code that can throw IOException or its subtypes
} catch (IOException e) {
// handles IOExceptions and its subtypes
} catch (FileNotFoundException ex) {
// handle FileNotFoundException only
}
The code below will compile successfully :-
try { 
// code that can throw IOException or its subtypes 
} catch (FileNotFoundException ex) { 
// handles IOExceptions and its subtypes 
} catch (IOException e){ 
// handle FileNotFoundException only 
} </pre>]]></answer>
		</qa>
		<qa id="174" rating="2">			<question><![CDATA[q:Does the order of the catch blocks matter if the Exceptions caught by them are not subtype or supertype of each other?]]></question>
			<answer><![CDATA[No. If the exceptions are siblings in the Exception class's hierarchy i.e. If one Exception class is not a subtype or supertype of the other, then the order in which their handlers(catch clauses) are placed does not matter.]]></answer>
		</qa>
		<qa id="175" rating="2">			<question><![CDATA[q:What happens if a method does not throw an checked Exception directly but calls a method that does? What does 'Ducking' the exception mean?]]></question>
			<answer><![CDATA[<pre>If a method does not throw an checked Exception directly but calls a method that throws an exception then the calling method must handle the throw exception or declare the exception in its throws clause. If the calling method does not handle and declares the exception, the exceptions is passed to the next method in the method stack. This is called as ducking the exception down the method stack.
e.g. The code below will not compile as the getCar() method has not declared the CarNotFoundException which is thrown by the getColor () method.
void getCar() {
getColor();
}
void getColor () {
throw new CarNotFoundException();
}
Fix for the above code is
void getCar() throws CarNotFoundException {
getColor();
}
void getColor () {
throw new CarNotFoundException();
}</pre>]]></answer>
		</qa>
		<qa id="176" rating="2">			<question><![CDATA[q:Is an empty catch block legal?]]></question>
			<answer><![CDATA[<pre>Yes you can leave the catch block without writing any actual code to handle the exception caught.
e.g. The code below is legal but not appropriate, as in this case you will nt get any information about the exception thrown.
try{
//code that may throw the FileNotFoundException
}catch(FileNotFound eFnf){
//no code to handle the FileNotFound exception
}</pre>]]></answer>
		</qa>
		<qa id="177" rating="2">			<question><![CDATA[q:)Can a catch block throw the exception caught by itself?]]></question>
			<answer><![CDATA[<pre>Yes. This is called rethrowing of the exception by catch block.
e.g. the catch block below catches the FileNotFound exception and rethrows it again.
void checkEx() throws FileNotFoundException {
try{
//code that may throw the FileNotFoundException
}catch(FileNotFound eFnf){
throw FileNotFound();
}
}</pre>]]></answer>
		</qa>
	</category>
	<category name="Garbage collection">
		<qa id="178" rating="2">			<question><![CDATA[q:  Explain garbage collection? 
  How you can force the garbage collection? 
  What is the purpose of garbage collection in Java, and when is it used? 
  What is Garbage Collection and how to call it explicitly? 
  Explain Garbage collection mechanism in Java?]]></question>
			<answer><![CDATA[Garbage collection is one of the most important features of Java. <br/>
The purpose of garbage collection is to identify and discard objects that are no longer needed by a program so that their resources can be reclaimed and reused. A Java object is subject to garbage collection when it becomes unreachable to the program in which it is used. Garbage collection is also called automatic memory management as JVM automatically removes the unused variables/objects (value is null) from the memory. <br/>
Every class inherits finalize() method from java.lang.Object, the finalize() method is called by garbage collector when it determines no more references to the object exists. In Java, it is good idea to explicitly assign null into a variable when no more in use. In Java on calling System.gc() and Runtime.gc(), JVM tries to recycle the unused objects, but there is no guarantee when all the objects will garbage collected. Garbage collection is an automatic process and can't be forced. There is no guarantee that Garbage collection will start immediately upon request of System.gc().]]></answer>
		</qa>
		<qa id="179" rating="2">			<question><![CDATA[q:  It is a daemon thread. Can an object's finalize() method be invoked while it is reachable?]]></question>
			<answer><![CDATA[An object's finalize() method cannot be invoked by the garbage collector while the object is still reachable. However, an object's finalize() method may be invoked by other objects.]]></answer>
		</qa>
		<qa id="180" rating="2">			<question><![CDATA[q: Does garbage collection guarantee that a program will not run out of memory?]]></question>
			<answer><![CDATA[Garbage collection does not guarantee that a program will not run out of memory. It is possible for programs to use up memory resources faster than they are garbage collected. It is also possible for programs to create objects that are not subject to garbage collection.]]></answer>
		</qa>
		<qa id="181" rating="2">			<question><![CDATA[q: What is the purpose of finalization?]]></question>
			<answer><![CDATA[The purpose of finalization is to give an unreachable object the opportunity to perform any cleanup, before the object gets garbage collected. For example, closing an opened database Connection.]]></answer>
		</qa>
		<qa id="182" rating="2">			<question><![CDATA[q: If an object is garbage collected, can it become reachable again?]]></question>
			<answer><![CDATA[Once an object is garbage collected, It can no longer become reachable again.]]></answer>
		</qa>
		<qa id="183" rating="2">			<question><![CDATA[q:Which part of the memory is involved in Garbage Collection? Stack or Heap?]]></question>
			<answer><![CDATA[Heap]]></answer>
		</qa>
		<qa id="184" rating="2">			<question><![CDATA[q:What is responsiblity of Garbage Collector?]]></question>
			<answer><![CDATA[Garbage collector frees the memory occupied by the unreachable objects during the java program by deleting these unreachable objects.
It ensures that the available memory will be used efficiently, but does not guarantee that there will be sufficient memory for the program to run.]]></answer>
		</qa>
		<qa id="185" rating="2

q:Garbage Collector is controlled by whom?
a: The JVM controls the Garbage Collector; it decides when to run the Garbage Collector. JVM runs the Garbage Collector when it realizes that the memory is running low, but this behavior of jvm can not be guaranteed.
One can request the Garbage Collection to happen from within the java program but there is no guarantee that this request will be taken care of by jvm.
r:3">			<question><![CDATA[q:Is garbage collector a dameon thread?]]></question>
			<answer><![CDATA[Yes GC is a dameon thread. A dameon thread runs behind the application. It is started by JVM. The thread stops when all non-dameon threads stop.]]></answer>
		</qa>
		<qa id="186" rating="2">			<question><![CDATA[q:When does an object become eligible for garbage collection?]]></question>
			<answer><![CDATA[An object becomes eligible for Garbage Collection when no live thread can access it.]]></answer>
		</qa>
		<qa id="187" rating="3">			<question><![CDATA[q:What are the different ways to make an object eligible for Garbage Collection when it is no longer needed?]]></question>
			<answer><![CDATA[<pre>
1. Set all available object references to null once the purpose of creating the object is served :


public class GarbageCollnTest1 {

   public static void main (String [] args){
String str = "Set the object ref to null";
//String object referenced by variable str is not eligible for GC yet

str = null;
/*String object referenced by variable str becomes eligible for GC */
   }

}
2. Make the reference variable to refer to another object : Decouple the reference variable from the object and set it refer to another object, so the object which it was referring to before reassigning is eligible for Garbage Collection.


publc class GarbageCollnTest2 {

   public static void main(String [] args){
String str1 = "Garbage collected after use";
String str2 = "Another String";
System.out.println(str1);
//String object referred by str1 is not eligible for GC yet

str1 = str2;
/* Now the str1 variable referes to the String object "Another String" and the object "Garbage collected after use" is not referred by any variable and hence is eligible for GC */

   }

}
3) Creating Islands of Isolation : If you have two instance reference variables which are referring to the instances of the same class, and these two reference variables refer to each other and the objects referred by these reference variables do not have any other valid reference then these two objects are said to form an Island of Isolation and are eligible for Garbage Collection.



public class GCTest3 {
GCTest3 g;

   public static void main(String [] str){
GCTest3 gc1 = new GCTest3();
GCTest3 gc2 = new GCTest3();
gc1.g = gc2; //gc1 refers to gc2
gc2.g = gc1; //gc2 refers to gc1
gc1 = null;
gc2 = null;
//gc1 and gc2 refer to each other and have no other valid //references
//gc1 and gc2 form Island of Isolation
//gc1 and gc2 are eligible for Garbage collection here
   }

}
</pre>]]></answer>
		</qa>
		<qa id="188" rating="2">			<question><![CDATA[q:Can the Garbage Collection be forced by any means?]]></question>
			<answer><![CDATA[No. The Garbage Collection can not be forced, though there are few ways by which it can be requested there is no guarantee that these requests will be taken care of by JVM.]]></answer>
		</qa>
		<qa id="189" rating="2">			<question><![CDATA[q:How can the Garbage Collection be requested?]]></question>
			<answer><![CDATA[<pre>There are two ways in which we can request the jvm to execute the Garbage Collection.

1)	The methods to perform the garbage collections are present in the Runtime class provided by java. The Runtime class is a Singleton for each java main program.
The method getRuntime() returns a singleton instance of the Runtime class. The method gc() can be invoked using this instance of Runtime to request the garbage collection.
2)	Call the System class System.gc() method which will request the jvm to perform GC.
</pre>]]></answer>
		</qa>
		<qa id="190" rating="3">			<question><![CDATA[q:What is the purpose of overriding finalize() method?]]></question>
			<answer><![CDATA[The finalize() method should be overridden for an object to include the clean up code or to dispose of the system resources that should to be done before the object is garbage collected.]]></answer>
		</qa>
		<qa id="191" rating="2">			<question><![CDATA[q:If an object becomes eligible for Garbage Collection and its finalize() method has been called and inside this method the object becomes accessible by a live thread of execution and is not garbage collected. Later at some point the same object becomes eligible for Garbage collection, will the finalize() method be called again?]]></question>
			<answer><![CDATA[No]]></answer>
		</qa>
		<qa id="192" rating="2">			<question><![CDATA[q:How many times does the garbage collector call the finalize() method for an object?]]></question>
			<answer><![CDATA[Only once.]]></answer>
		</qa>
		<qa id="193" rating="3">			<question><![CDATA[q:What happens if an uncaught exception is thrown from during the execution of the finalize() method of an object?]]></question>
			<answer><![CDATA[The exception will be ignored and the garbage collection (finalization) of that object terminates.]]></answer>
		</qa>
		<qa id="194" rating="2">			<question><![CDATA[q:What are different ways to call garbage collector?]]></question>
			<answer><![CDATA[Garbage collection can be invoked using System.gc() or Runtime.getRuntime().gc().]]></answer>
		</qa>
		<qa id="195" rating="3">			<question><![CDATA[q:How to enable/disable call of finalize() method of exit of the application]]></question>
			<answer><![CDATA[Runtime.getRuntime().runFinalizersOnExit(boolean value) . Passing the boolean value will either disable or enable the finalize() call.]]></answer>
		</qa>
		<qa id="196" rating="3">			<question><![CDATA[q:What are the different types of references in java?]]></question>
			<answer><![CDATA[<pre>Java has a more expressive system of reference than most other garbage-collected programming languages, which allows for special behavior for garbage collection. A normal reference in Java is known as a strong reference. The java.lang.ref package defines three other types of referencessoft, weak, and phantom references. Each type of reference is designed for a specific use.

A <b>SoftReference</b> can be used to implement a cache. An object that is not reachable by a strong reference (that is, not strongly reachable), but is referenced by a soft reference is called softly reachable. A softly reachable object may be garbage collected at the discretion of the garbage collector. This generally means that softly reachable objects will only be garbage collected when free memory is low, but again, it is at the discretion of the garbage collector. Semantically, a soft reference means "keep this object unless the memory is needed."

A <b>WeakReference</b> is used to implement weak maps. An object that is not strongly or softly reachable, but is referenced by a weak reference is called weakly reachable. A weakly reachable object will be garbage collected during the next collection cycle. This behavior is used in the class java.util.WeakHashMap. A weak map allows the programmer to put key/value pairs in the map and not worry about the objects taking up memory when the key is no longer reachable anywhere else. Another possible application of weak references is the string intern pool. Semantically, a weak reference means "get rid of this object when nothing else references it."


A <b>PhantomReference </b>is used to reference objects that have been marked for garbage collection and have been finalized, but have not yet been reclaimed. An object that is not strongly, softly or weakly reachable, but is referenced by a phantom reference is called phantom reachable. This allows for more flexible cleanup than is possible with the finalization mechanism alone. Semantically, a phantom reference means "this object is no longer needed and has been finalized in preparation for being collected."
</pre>]]></answer>
		</qa>
		<qa id="197" rating="3">			<question><![CDATA[q:How to change the heap size of a JVM?]]></question>
			<answer><![CDATA[The old generation's default heap size can be overridden by using the -Xms and -Xmx switches to specify the initial and maximum sizes respectively: 
   java -Xms <initial size> -Xmx <maximum size> program<br/>
For example: java -Xms64m -Xmx128m program]]></answer>
		</qa>
	</category>
	<category name="Inner class">
		<qa id="198" rating="2">			<question><![CDATA[q: What is an inner class?]]></question>
			<answer><![CDATA[Inner class is a class defined inside other class and act like a member of the enclosing class.]]></answer>
		</qa>
		<qa id="199" rating="2">			<question><![CDATA[q: What are the different types of inner classes?]]></question>
			<answer><![CDATA[<pre>
Static member class
Inner class
Member class
Anonymous class
Local class
</pre>]]></answer>
		</qa>
		<qa id="200" rating="InnerClass.StaticInner staticObj= new InnerClass. StaticInner ();
No outer class instance is required to instantiate the nested static class because the static class is a static member of the enclosing class.
</pre>
r:2">			<question><![CDATA[q: What is static member class?]]></question>
			<answer><![CDATA[<pre>A static member class behaves much like an ordinary top-level class, except that it can access the static members of the class that contains it. The static nested class can be accessed as the other static members of the enclosing class without having an instance of the outer class. The static class can contain non-static and static members and methods.
public class InnerClass {
      static class StaticInner {
            static int i = 9; 
            int no = 6;
            private void method() {}
            public void method1() {}
            static void method2() {}
            final void method3() {}
      } 
}
      The static inner class can be accessed from Outer Class in the following manne]]></answer>
		</qa>
		<qa id="201" rating="2">			<question><![CDATA[q: What are non static inner classes?]]></question>
			<answer><![CDATA[<pre>The different type of static inner classes are: 
Non - static inner classes - classes associated with the object of the enclosing class. Member class - Classes declared outside a function (hence a "member") and not declared "static".
The member class can be declared as public, private, protected, final and abstract. E.g.
	public class InnerClass {
		class MemberClass {
			public void method1() { }
			} 
	}
Method local class - The inner class declared inside the method is called method local inner class. Method local inner class can only be declared as final or abstract.	 Method local class can only access global variables or method local variables if declared as final
	public class InnerClass {
		int i = 9;
		public void method1() {
			final int k = 6; 
			class MethodLocal { 
					MethodLocal() { 
					System.out.println(k + i); 
					} 
			} 
		} 
	}
Anonymous inner class - These are local classes which are automatically declared and instantiated in the middle of an expression.  Also, like local classes, anonymous classes cannot be public, private, protected, or static. They can specify arguments to the constructor of the superclass, but cannot otherwise have a constructor. They can implement only one interface or extend a class.
Anonymous class cannot define any static fields, methods, or classes, except for static final constants.
Also, like local classes, anonymous classes cannot be public, private, protected, or static
Some examples:
		public class MyFrame extends JFrame {
			JButton btn = new JButton(); 
				MyFrame() { 
				btn.addActionListener(new ActionListener() { 
					public void actionPerformed(ActionEvent e) { 
					} 
				}); 
			} 
		}
		
		Anonymous class used with comparator
		
			List<Parent> l = new ArrayList<Parent>(); 
			l.add(new Parent(2)); 
			l.add(new Parent(3)); 
			Collections.sort(l, new Comparator() { 
					public int compare(Object o1, Object o2) { 
						Parent prt1 = (Parent) o1; 
						Parent prt2 = (Parent) o2; 
						if (prt1.getAge() > prt2.getAge()) {
							return -1; 
						}else if(prt1.getAge()<prt2.getAge()) {
							return 1; 
						} else {
							return 0;
						} 
					} 
				});
</pre>]]></answer>
		</qa>
		<qa id="202" rating="2">			<question><![CDATA[q: Does a static nested class have access to the enclosing class' non-static methods or instance variables?]]></question>
			<answer><![CDATA[No .]]></answer>
		</qa>
		<qa id="203" rating="2">			<question><![CDATA[q:What are the advantages of Inner classes?]]></question>
			<answer><![CDATA[<pre>The embedding of inner class into the outer class in the case when the inner class is to be used only by one class i.e. the outer class makes the package more streamlined. Nesting the inner class code where it is used (inside the outer class) makes the code more readable and maintainable.
The inner class shares a special relationship with the outer class i.e. the inner class has access to all members of the outer class and still have its own type is the main advantages of Inner class. Advantage of inner class is that they can be hidden from the other classes in the same package and still have the access to all the members (private also) of the enclosing class. So the outer class members which are going to be used by the inner class can be made private and the inner class members can be hidden from the classes in the same package. This increases the level of encapsulation.
If a class A is written requires another class B for its own use, there are two ways to do this. One way is to write a separate class B or to write an inner class B inside class A. Advantage of writing the inner class B in the class A is you can avoid having a separate class. Inner classes are best used in the event handling mechanism and to implement the helper classes. The advantage of using inner class for event handling mechanism is that the use of if/else to select the component to be handled can be avoided. If inner classes are used each component gets its own event handler and each event handler implicitly knows the component it is working for. e.g. Button btn1 = new Button("Submit"); Btn.addActionListener(new ActionListener(){/br>
Public void actionPerformed(ActionEvent ae){ submitClicked(); }
} );
The advantage of using static nested class is that to instantiate a static nested class you need not create an instance of the enclosing class which reduces the number of objects the application creates at runtime.
</pre>]]></answer>
		</qa>
		<qa id="204" rating="2">			<question><![CDATA[q:What are disadvantages of using inner classes?]]></question>
			<answer><![CDATA[1. Using inner class increases the total number of classes being used by the application. For all the classes created by JVM and loaded in the memory, jvm has to perform some tasks like creating the object of type class. Jvm may have to perform some routine tasks for these extra classes created which may result slower performance if the application is using more number of inner classes. 2. Inner classes get limited support of ide/tools as compared to the top level classes, so working with the inner classes is sometimes annoying for the developer.]]></answer>
		</qa>
		<qa id="205" rating="2">			<question><![CDATA[q: What are different types of anonymous classes?]]></question>
			<answer><![CDATA[<pre>1) Plain old anonymous class type one- 
e.g. 
class superClass{ 
         void doSomething() { 
                  System.out.println("Doing something in the Super class"); 
         } 
 } 
class hasAnonymous{ 
               superClass anon = new superClass(){ 
                       void doSomething() { 
                               System.out.println("Doing something in the Anonymous class"); 
                     } 
            }; 
Here anon is the reference which is of type superClass which is the class extended by the anonymous class i.e. superclass of the anonymous class. The method doSomething() is the super class method overridden by the anonymous class. 
2) Plain old anonymous class type two - 
interface Eatable{ 
       public void prepareSweets(); 
 } 
class serveMeal{ 
 Eatable food = new Eatable(){ 
              public void prepareSweets(){ //come implementation code goes here } 
     }; 
} 
 food is reference variable of type Eatable interface which refers to the anonymous class which is the implementer of the interface Eatable. The anonymous implementer class of the interface Eatable implements its method prepareSweets() inside it. 
3) Argument defined anonymous class - 
e.g. 
interface Vehicle { 
   void getNoOfWheels(); 
 } 
class Car { 
       void getType(Vehical v) { } 
} 
class BeautifulCars { 
        void getTheBeautifilCar() { 
             Car c = new Car (); 
             c.getType (new Vehicle () { 
                          public void getNoOfWheels () { 
                                 System.out.println("It has four wheels"); 
                          } 
             }); 
        } 
 } 
 Anonymous class is defined as the argument of the method getTheBeautifilCar(), this anonymous class is the implementer of the interface Vehicle. The method of class Car getTheBeautifilCar() expects the argument as an object of type Vehicle. So first we create an object of Car referenced by the variable 'c'. On this object of Car we call the method getTheBeautifilCar() and in the argument we create an anonymous class in place which is the implementer of interface Vehicle hence of type Vehicle.
</pre>]]></answer>
		</qa>
		<qa id="206" rating="2">			<question><![CDATA[q: If you compile a file containing inner class how many .class files are created and what are all of them accessible in usual way?]]></question>
			<answer><![CDATA[<pre>If a inner class enclosed with an outer class is compiled then one .class file for each inner class an a .class file for the outer class is created. e.g. 
class EnclosingOuter { 
    class Inner{ } 
 } 
 
 If you compile the above code with command 
% javac EnclosingOuter.java 
Two files 
EnclosingOuter.class 
EnclosingOuter$Inner.class 
will be created. Though a separate inner class file is generated, the inner class file is not accessible in the usual way like, 
% java EnclosingOuter$Inner
</pre>]]></answer>
		</qa>
		<qa id="207" rating="2">			<question><![CDATA[q: How to access the inner class from code within the outer class?]]></question>
			<answer><![CDATA[<pre>The inner class is instantiated only through the outer class instance. 
class EnclosingOuter { 
private int noInnerClass = 1; 
public void getNoOfInnerClasses(){ 
           Inner in = new Inner(); 
System.out.println("No Of Inner classes is : "+ in.getNoOfClassesFromOuter()); 
} 
class Inner{ 
public int getNoOfClassesFromOuter(){ return noInnerClass; } 
} 
Here the method getNoOfInnerClasses() is called on the outer class's instance through this outer class instance the inner class instance in is created.
</pre>]]></answer>
		</qa>
		<qa id="208" rating="2">			<question><![CDATA[q: How to create an inner class instance from outside the outer class instance code?]]></question>
			<answer><![CDATA[<pre> To create an instance of the inner class you must have the instance of its enclosing class. 
e.g. class EnclosingOuter { 
class Inner{ } 
} 
 To create the instance of inner class from class other than the enclosing class. 
1) class OtherThanOuter{ 
EnclosingOuter out = new EnclosingOuter(); 
EnclosingOuter.Inner in = out.new Inner(); 
} 
2) class OtherThanOuter{ 
EnclosingOuter.Inner out = new EnclosingOuter.Inner (); }
</pre>]]></answer>
		</qa>
		<qa id="209" rating="2">			<question><![CDATA[q: How to refer to the outer this i.e. outer class's current instance from inside the inner class?]]></question>
			<answer><![CDATA[<pre>The outer this reference i.e. the outer class' current instance' reference can be refered using 'OuterClassName.this'. E.g 
 class EnclosingOuter { 
           class Inner{ 
          System.out.println("Inner class reference is " + this); // inner class instance
System.out.println("Outer class reference is " + EnclosingOuter.this); //outer class instance 
 } 
} 
To refer the inner class reference from within the inner class use this.</pre>]]></answer>
		</qa>
		<qa id="210" rating="public 
     private 
     abstract 
     final 
     protected 
     strictfp 
     static - turns the inner class into static nested class.</pre>
r:2">			<question><![CDATA[q: Which modifiers can be applied to the inner class?]]></question>
			<answer><![CDATA[<pre>Following are modifiers that can be applied to the inne]]></answer>
		</qa>
		<qa id="211" rating="2">			<question><![CDATA[q: Can the method local inner class object access method's local variables?]]></question>
			<answer><![CDATA[No, a method local inner class object can not access the method local variable. 
Reason: The local variables are not guaranteed to live as long as the local inner class object. The method local variable live on stack and exist only till the method lives, their scope is limited only code inside the method they are declared in. But the local inner class object created within the method lives on heap and it may exist even after the method ends if in case the reference of this local inner class is passed into some other code and is stored in an instance variable. So we can not be sure that the local variables will live till the method local inner class object lives, therefore the method local inner class object can not access the method local variable. To access the method local variables, the variable has to be declared as final.]]></answer>
		</qa>
		<qa id="212" rating="2">			<question><![CDATA[q: Can a method local inner class access the local final variables?Why?]]></question>
			<answer><![CDATA[Yes. Because the final variables are stored on heap and they live as long as the method local inner class object may live.]]></answer>
		</qa>
		<qa id="213" rating="2">			<question><![CDATA[q: Which modifiers can be applied to the method local inner class?]]></question>
			<answer><![CDATA[Only abstract or final keyword isallowed.]]></answer>
		</qa>
		<qa id="214" rating="2">			<question><![CDATA[q: Can a local class declared inside a static method have access to the instance members of the outer class?]]></question>
			<answer><![CDATA[No. There is no this reference available in the static method .The static method class can not have access to any members of the outer class other than static members.]]></answer>
		</qa>
		<qa id="215" rating="2">			<question><![CDATA[q: Can a method which is not in the definition of the superclass of an anonymous class be invoked on that anonymous class reference?]]></question>
			<answer><![CDATA[<pre>No. Compilation will fail.As the reference variable type of the anonymous class will be of superclass which will not know of any method defined inside the anonymous class the compilation will fail. 
e.g. class SuperClass{ 
             void doSomething() { 
                       System.out.println("In the Super class"); 
             } 
 } 
class hasAnonymous{ 
SuperClass anon = new SuperClass(){ 
                void doSomething() { 
                   System.out.println("In the Anonymous class"); 
                } 
             void doStuff() { 
                    System.out.println("An Anonymous class method not present in superClass"); 
            } 
 }; 
public void doIt(){ 
      anon.doSomething(); // legal superClass has this method 
      anon.doStuff(); // Not legal } 
} 
 The above code does not compile as the superClass does not know about the anonymous class method doStuff().
</pre>]]></answer>
		</qa>
		<qa id="216" rating="2">			<question><![CDATA[q: Can an anonymous class define method of its own?]]></question>
			<answer><![CDATA[Yes. But there will be no way by which the methods defined in the anonymous class which are not present in its superclass be invoked. As only those methods which are defined in the suprclass which the anonymous class extends be invoked defining the methods in the anonymous class will be of no use.]]></answer>
		</qa>
		<qa id="217" rating="2">			<question><![CDATA[q: Can an anonymous class implement multiple interfaces directly?]]></question>
			<answer><![CDATA[No. An anonymous class can implement only one interface. If the anonymous class is extending a class then it becomes the implementer of all the interfaces implemented by its superclass automatically.]]></answer>
		</qa>
		<qa id="218" rating="2">			<question><![CDATA[q: Can an anonymous class implement an interface and also extend a class at the same time?]]></question>
			<answer><![CDATA[No. An anonymous class can either extend a class or implement a single interface. If the anonymous class is extending a class then it becomes the implementer of all the interfaces implemented by its superclass automatically.]]></answer>
		</qa>
	</category>
	<category name="Serialization">
		<qa id="219" rating="2">			<question><![CDATA[q: What is Serializable?]]></question>
			<answer><![CDATA[Serializable is a marker interface. When an object has to be transferred over a network ( typically through rmi or EJB) or persist the state of an object to a file, the object Class needs to implement Serializable interface. Implementing this interface will allow the object converted into bytestream and transfer over a network.]]></answer>
		</qa>
		<qa id="220" rating="2">			<question><![CDATA[q: What is use of serialVersionUID?]]></question>
			<answer><![CDATA[During object serialization, the default Java serialization mechanism writes the metadata about the object, which includes the class name, field names and types, and superclass. This class definition is stored as a part of the serialized object. This stored metadata enables the deserialization process to reconstitute the objects and map the stream data into the class attributes with the appropriate type
Everytime an object is serialized the java serialization mechanism automatically computes a hash value. ObjectStreamClass's computeSerialVersionUID() method passes the class name, sorted member names, modifiers, and interfaces to the secure hash algorithm (SHA), which returns a hash value.The serialVersionUID is also called suid.
So when the serilaize object is retrieved , the JVM first evaluates the suid of the serialized class and compares the suid value with the one of the object. If the suid values match then the object is said to be compatible with the class and hence it is de-serialized. If not InvalidClassException exception is thrown.
Changes to a serializable class can be compatible or incompatible.]]></answer>
		</qa>
		<qa id="221" rating="2">			<question><![CDATA[q: What is the need of Serialization?]]></question>
			<answer><![CDATA[<pre>The serialization is used :-
To send state of one or more object's state over the network through a socket.
To save the state of an object in a file.
An object's state needs to be manipulated as a stream of bytes.</pre>]]></answer>
		</qa>
		<qa id="222" rating="2">			<question><![CDATA[q: Other than Serialization what are the different approach to make object Serializable?]]></question>
			<answer><![CDATA[<pre>Besides the Serializable interface, at least three alternate approaches can serialize Java objects: 
1)For object serialization, instead of implementing the Serializable interface, a developer can implement the Externalizable interface, which extends Serializable. By implementing Externalizable, a developer is responsible for implementing the writeExternal() and readExternal() methods. As a result, a developer has sole control over reading and writing the serialized objects.
2)XML serialization is an often-used approach for data interchange. This approach lags runtime performance when compared with Java serialization, both in terms of the size of the object and the processing time. With a speedier XML parser, the performance gap with respect to the processing time narrows. Nonetheless, XML serialization provides a more malleable solution when faced with changes in the serializable object.
3)Finally, consider a "roll-your-own" serialization approach. You can write an object's content directly via either the ObjectOutputStream or the DataOutputStream. While this approach is more involved in its initial implementation, it offers the greatest flexibility and extensibility. In addition, this approach provides a performance advantage over Java serialization.
</pre>]]></answer>
		</qa>
		<qa id="223" rating="2">			<question><![CDATA[q: Do we need to implement any method of Serializable interface to make an object serializable?]]></question>
			<answer><![CDATA[No. Serializable is a Marker Interface. It does not have any methods.]]></answer>
		</qa>
		<qa id="224" rating="2">			<question><![CDATA[q: What happens if the object to be serialized includes the references to other serializable objects?]]></question>
			<answer><![CDATA[If the object to be serialized includes the references to other objects whose class implements serializable then all those object's state also will be saved as the part of the serialized state of the object in question. The whole object graph of the object to be serialized will be saved during serialization automatically provided all the objects included in the object's graph are serializable.]]></answer>
		</qa>
		<qa id="225" rating="2">			<question><![CDATA[q: What happens if an object is serializable but it includes a reference to a non-serializable object?]]></question>
			<answer><![CDATA[<pre> If you try to serialize an object of a class which implements serializable, but the object includes a reference to an non-serializable class then a 'NotSerializableException' will be thrown at runtime.

e.g.
public class NonSerial { 
    //This is a non-serializable class 
}
public class MyClass implements Serializable{ 
    private static final long serialVersionUID = 1L; 
    private NonSerial nonSerial; 
    MyClass(NonSerial nonSerial){ 
        this.nonSerial = nonSerial; 
    } 
    public static void main(String [] args) { 
        NonSerial nonSer = new NonSerial(); 
        MyClass c = new MyClass(nonSer); 
        try { 
        FileOutputStream fs = new FileOutputStream("test1.ser"); 
        ObjectOutputStream os = new ObjectOutputStream(fs); 
        os.writeObject(c); 
        os.close(); 
        } catch (Exception e) { e.printStackTrace(); } 
        try { 
        FileInputStream fis = new FileInputStream("test1.ser"); 
        ObjectInputStream ois = new ObjectInputStream(fis); 
        c = (MyClass) ois.readObject(); 
        ois.close(); 
            } catch (Exception e) { 
            e.printStackTrace(); 
          } 
    } 
}
On execution of above code following exception will be thrown  -
java.io.NotSerializableException: NonSerial 
            at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java) 
 </pre>]]></answer>
		</qa>
		<qa id="226" rating="2">			<question><![CDATA[q: Are the static variables saved as the part of serialization?]]></question>
			<answer><![CDATA[No. The static variables belong to the class and not to an object they are not the part of the state of the object so they are not saved as the part of serialized object.]]></answer>
		</qa>
		<qa id="227" rating="2">			<question><![CDATA[q: What is a transient variable?]]></question>
			<answer><![CDATA[These variables are not included in the process of serialization and are not the part of the object's serialized state.]]></answer>
		</qa>
		<qa id="228" rating="2">			<question><![CDATA[q: What will be the value of transient variable after de-serialization?]]></question>
			<answer><![CDATA[<pre>It's default value.
e.g. if the transient variable in question is an int, it's value after deserialization will be zero.
public class TestTransientVal implements Serializable{ 
    
    private static final long serialVersionUID = -22L; 
    private String name; 
    transient private int age; 
    TestTransientVal(int age, String name) { 
        this.age = age; 
        this.name = name; 
    } 
    public static void main(String [] args) { 
        TestTransientVal c = new TestTransientVal(1,"ONE"); 
        System.out.println("Before serialization: - " + c.name + " "+ c.age); 
        try { 
        FileOutputStream fs = new FileOutputStream("testTransients.ser"); 
        ObjectOutputStream os = new ObjectOutputStream(fs); 
        os.writeObject(c); 
        os.close(); 
        } catch (Exception e) { e.printStackTrace(); } 

        try { 
        FileInputStream fis = new FileInputStream("testTransients.ser"); 
        ObjectInputStream ois = new ObjectInputStream(fis); 
        c = (TestTransientVal) ois.readObject(); 
        ois.close(); 
        } catch (Exception e) { e.printStackTrace(); } 
        System.out.println("After de-serialization:- " + c.name + " "+ c.age); 
        }
}

Result of executing above piece of code -
Before serialization: - Value of non-transient variable ONE Value of transient variable 1 
After de-serialization:- Value of non-transient variable ONE Value of transient variable 0
Explanation - 
The transient variable is not saved as the part of the state of the serailized variable, it's value after de-serialization is it's default value.
</pre>]]></answer>
		</qa>
		<qa id="229" rating="2">			<question><![CDATA[q: Does the order in which the value of the transient variables and the state of the object using the defaultWriteObject() method are saved during serialization matter?]]></question>
			<answer><![CDATA[Yes.  As while restoring the object's state the transient variables and the serializable variables that are stored must be restored in the same order in which they were saved.]]></answer>
		</qa>
		<qa id="230" rating="3">			<question><![CDATA[q: How can one customize the Serialization process? or What is the purpose of implementing the writeObject() and readObject() method?]]></question>
			<answer><![CDATA[<pre>When you want to store the transient variables state as a part of the serialized object at the time of serialization the class must implement the following methods -
private void wrtiteObject(ObjectOutputStream outStream)
{
//code to save the transient variables state as a part of serialized object
}
private void readObject(ObjectInputStream inStream)
{
//code to read the transient variables state and assign it to the de-serialized object
}
</pre>]]></answer>
		</qa>
		<qa id="231" rating="3">			<question><![CDATA[q: If a class is serializable but its superclass in not , what will be the state of the instance variables inherited  from super class after deserialization?]]></question>
			<answer><![CDATA[<pre> The values of the instance variables inherited from superclass will be reset to the values they were given during the original construction of the object as the non-serializable super-class constructor will run.
E.g.
public class ParentNonSerializable { 
    int noOfWheels; 
    
    ParentNonSerializable(){ 
        this.noOfWheels = 4; 
    } 
    
}

public class ChildSerializable extends ParentNonSerializable implements Serializable { 
   
    private static final long serialVersionUID = 1L; 
    String color;

    ChildSerializable() { 
        this.noOfWheels = 8; 
        this.color = "blue"; 
    } 
}

public class SubSerialSuperNotSerial { 
    public static void main(String [] args) { 
        ChildSerializable c = new ChildSerializable(); 
        System.out.println("Before : - " + c.noOfWheels + " "+ c.color); 
        try { 
        FileOutputStream fs = new FileOutputStream("superNotSerail.ser"); 
        ObjectOutputStream os = new ObjectOutputStream(fs); 
        os.writeObject(c); 
        os.close(); 
        } catch (Exception e) { e.printStackTrace(); } 
        try { 
        FileInputStream fis = new FileInputStream("superNotSerail.ser"); 
        ObjectInputStream ois = new ObjectInputStream(fis); 
        c = (ChildSerializable) ois.readObject(); 
        ois.close(); 
        } catch (Exception e) { e.printStackTrace(); } 
        System.out.println("After :- " + c.noOfWheels + " "+ c.color); 
        }
}
Result on executing above code -
Before : - 8 blue 
After :- 4 blue
The instance variable 'noOfWheels' is inherited from superclass which is not serializable. Therefore while restoring it the non-serializable superclass constructor runs and its value is set to 8 and is not same as the value saved during serialization which is 4.</pre>]]></answer>
		</qa>
		<qa id="232" rating="2">			<question><![CDATA[q: To serialize an array or a collection all the members of it must be serializable. True /False?]]></question>
			<answer><![CDATA[true.]]></answer>
		</qa>
		<qa id="233" rating="2">			<question><![CDATA[q:  How many methods in the Serializable interface? Which methods of Serializable interface should I implement?]]></question>
			<answer><![CDATA[There is no method in the Serializable interface. It's an empty interface which does not contain any methods. The Serializable interface acts as a marker, telling the object serialization tools that the class is serializable. So we do not implement any methods.]]></answer>
		</qa>
		<qa id="234" rating="2">			<question><![CDATA[q:  What is the difference between Serializalble and Externalizable interface? How can you control over the serialization process i.e. how can you customize the seralization process?]]></question>
			<answer><![CDATA[When you use Serializable interface, your class is serialized automatically by default. But you can override writeObject() and readObject() two methods to control more complex object serailization process. When you use Externalizable interface, you have a complete control over your class's serialization process. This interface contains two methods namely readExternal and writeExternal. You should implement these methods and write the logic for customizing the serialization process.]]></answer>
		</qa>
		<qa id="235" rating="2">			<question><![CDATA[q:  What interface must an object implement before it can be written to a stream as an object?]]></question>
			<answer><![CDATA[An object must implement the Serializable or Externalizable interface before it can be written to a stream as an object. The class whose instances are to be serialized should implement an interface Serializable. Then you pass the instance to the ObjectOutputStream which is connected to a fileoutputstream. This will save the object to a file.]]></answer>
		</qa>
		<qa id="236" rating="2">			<question><![CDATA[q:  What happens to the object references included in the object?]]></question>
			<answer><![CDATA[The serialization mechanism generates an object graph for serialization. Thus it determines whether the included object references are serializable or not. This is a recursive process. Thus when an object is serialized, all the included objects are also serialized alongwith the original object.]]></answer>
		</qa>
		<qa id="237" rating="2">			<question><![CDATA[q:  What is serialization?]]></question>
			<answer><![CDATA[The serialization is a kind of mechanism that makes a class or a bean persistent by having its properties or fields and state information saved and restored to and from storage. That is, it is a mechanism with which you can save the state of an object by converting it to a byte stream.]]></answer>
		</qa>
		<qa id="238" rating="2">			<question><![CDATA[q:  Common Usage of serialization.]]></question>
			<answer><![CDATA[Whenever an object is to be sent over the network or saved in a file, objects are serialized.]]></answer>
		</qa>
		<qa id="239" rating="2">			<question><![CDATA[q:  What happens to the static fields of a class during serialization?]]></question>
			<answer><![CDATA[There are three exceptions in which serialization doesn't necessarily read and write to the stream. These are 
 1. Serialization ignores static fields, because they are not part of any particular state. 
 2. Base class fields are only handled if the base class itself is serializable. 
 3. Transient fields.]]></answer>
		</qa>
		<qa id="240" rating="2">			<question><![CDATA[q:  What one should take care of while serializing the object?]]></question>
			<answer><![CDATA[One should make sure that all the included objects are also serializable. If any of the objects is not serializable then it throws a NotSerializableException.]]></answer>
		</qa>
		<qa id="241" rating="2">			<question><![CDATA[q:  What is a transient variable?  Explain the usage of the keyword transient?  What are Transient and Volatile Modifiers]]></question>
			<answer><![CDATA[A transient variable is a variable that may not be serialized i.e. the value of the variable can't be written to the stream in a Serializable class. If you don't want some field to be serialized, you can mark that field transient or static. In such a case when the class is retrieved from the ObjectStream the value of the variable is null. 
 Volatile modifier applies to variables only and it tells the compiler that the variable modified by volatile can be changed unexpectedly by other parts of the program.]]></answer>
		</qa>
		<qa id="242" rating="2">			<question><![CDATA[q: What is Serialization and deserialization?]]></question>
			<answer><![CDATA[Serialization is the process of writing the state of an object to a byte stream. Deserialization is the process of restoring these objects.]]></answer>
		</qa>
		<qa id="243" rating="2">			<question><![CDATA[q: What is Externalizable?]]></question>
			<answer><![CDATA[Externalizable is an interface which contains two methods readExternal and writeExternal. These methods give you a control over the serialization mechanism. Thus if your class implements this interface, you can customize the serialization process by implementing these methods.]]></answer>
		</qa>
	</category>
	<category name="Swing">
		<qa id="244" rating="2">			<question><![CDATA[q:  What is the difference between Swing and AWT components?]]></question>
			<answer><![CDATA[AWT components are heavy-weight, whereas Swing components are lightweight. Hence Swing works faster than AWT. Heavy weight components depend on the local windowing toolkit. For example, java.awt.Button is a heavy weight component. Pluggable look and feel possible using java Swing. Also, we can switch from one look and feel to another at runtime in swing which is not possible in AWT.]]></answer>
		</qa>
		<qa id="245" rating="2">			<question><![CDATA[q:  Name the containers which use Border Layout as their default layout?]]></question>
			<answer><![CDATA[window, Frame and Dialog classes. 
  Window, Frame, Dialog, FileDialog, Panel, Applet, or ScrollPane]]></answer>
		</qa>
		<qa id="246" rating="2">			<question><![CDATA[q: How can a GUI component handle its own events?]]></question>
			<answer><![CDATA[A component can handle its own events by implementing the required event-listener interface and adding itself as its own event listener.]]></answer>
		</qa>
		<qa id="247" rating="2">			<question><![CDATA[q: What is the difference between the paint() and repaint() methods?]]></question>
			<answer><![CDATA[The paint() method supports painting via a Graphics object. The repaint() method is used to cause paint() to be invoked by the AWT painting thread.]]></answer>
		</qa>
		<qa id="248" rating="2">			<question><![CDATA[q: Which package has light weight components?]]></question>
			<answer><![CDATA[javax.Swing package contains light weight components. All components in Swing, except JApplet, JDialog, JFrame and JWindow are lightweight components.]]></answer>
		</qa>
		<qa id="249" rating="2">			<question><![CDATA[q: What are peerless components?]]></question>
			<answer><![CDATA[The peerless components are called light weight components.]]></answer>
		</qa>
		<qa id="250" rating="2">			<question><![CDATA[q: What is a Container in a GUI?]]></question>
			<answer><![CDATA[A Container contains and arranges other components (including other containers) through the use of layout managers, which use specific layout policies to determine where components should go as a function of the size of the container.]]></answer>
		</qa>
		<qa id="251" rating="2">			<question><![CDATA[q: How are the elements of a GridBagLayout organized? 
 What is a layout manager and what are different types of layout managers available in java Swing? 
 How are the elements of different layouts organized?]]></question>
			<answer><![CDATA[A layout manager is an object that is used to organize components in a container. The different layouts available are FlowLayout, BorderLayout, CardLayout, GridLayout and GridBagLayout. 
FlowLayout: The elements of a FlowLayout are organized in a top to bottom, left to right fashion. 
BorderLayout: The elements of a BorderLayout are organized at the borders (North, South, East and West) and the center of a container. 
CardLayout: The elements of a CardLayout are stacked, on top of the other, like a deck of cards. 
GridLayout: The elements of a GridLayout are of equal size and are laid out using the square of a grid. 
GridBagLayout: The elements of a GridBagLayout are organized according to a grid. However, the elements may be different sizes and may occupy more than one row or column of the grid. In addition, the rows and columns may have different sizes.]]></answer>
		</qa>
		<qa id="252" rating="2">			<question><![CDATA[q:  What advantage do Java's layout managers provide over traditional windowing systems?]]></question>
			<answer><![CDATA[Java uses layout managers to lay out components in a consistent manner across all windowing platforms. Since Java's layout managers aren't tied to absolute sizing and positioning, they are able to accommodate platform-specific differences among windowing systems.]]></answer>
		</qa>
		<qa id="253" rating="2">			<question><![CDATA[q:  What method is used to specify a container's layout?]]></question>
			<answer><![CDATA[The setLayout() method is used to specify a container's layout. For example, setLayout(new FlowLayout()); will be set the layout as FlowLayout.]]></answer>
		</qa>
		<qa id="254" rating="2">			<question><![CDATA[q:  Which Container method is used to cause a container to be laid out and redisplayed?]]></question>
			<answer><![CDATA[validate()]]></answer>
		</qa>
		<qa id="255" rating="2">			<question><![CDATA[q:  Name Component subclasses that support painting.]]></question>
			<answer><![CDATA[The Canvas, Frame, Panel, and Applet classes support painting.]]></answer>
		</qa>
		<qa id="256" rating="2">			<question><![CDATA[q:  What is the purpose of the enableEvents() method?]]></question>
			<answer><![CDATA[The enableEvents() method is used to enable an event for a particular component. Normally, an event is enabled when a listener is added to an object for a particular event. The enableEvents() method is used by objects that handle events by overriding their event-dispatch methods.]]></answer>
		</qa>
		<qa id="257" rating="2">			<question><![CDATA[q:  What is the difference between a Window and a Frame?]]></question>
			<answer><![CDATA[The Frame class extends Window to define a main application window that can have a menu bar.]]></answer>
		</qa>
		<qa id="258" rating="2">			<question><![CDATA[q:  What do heavy weight components mean?]]></question>
			<answer><![CDATA[Heavy weight components like Abstract Window Toolkit (AWT) depend on the local windowing toolkit. For example, java.awt .Button is a heavy weight component.]]></answer>
		</qa>
		<qa id="259" rating="2">			<question><![CDATA[q:  What is the difference between a Scrollbar and a ScrollPane?]]></question>
			<answer><![CDATA[A Scrollbar is just a Component, but not a Container. A ScrollPane is a Container. A ScrollPane handles its own events and performs its own scrolling.]]></answer>
		</qa>
		<qa id="260" rating="2">			<question><![CDATA[q:  What is the preferred size of a component?]]></question>
			<answer><![CDATA[The preferred size of a component is the minimum component size that will allow the component to display normally.]]></answer>
		</qa>
		<qa id="261" rating="2">			<question><![CDATA[q:  Which containers use a FlowLayout as their default layout?]]></question>
			<answer><![CDATA[The Panel and Applet classes use the FlowLayout as their default layout.]]></answer>
		</qa>
	</category>
	<category name="Threads">
		<qa id="262" rating="2">			<question><![CDATA[q:What is a Thread?]]></question>
			<answer><![CDATA[<pre>In Java, "thread" means two different things:

* An instance of class java.lang.Thread.
*A thread of execution.
An instance of Thread is just an object. Like any other object in Java, it has variables and methods, and lives and dies on the heap. But a thread of execution is an individual process (a "lightweight" process) that has its own call stack. In Java, there is one thread per call stackor, to think of it in reverse, one call stack per thread. Even if you don't create any new threads in your program, threads are back there running. 

The main() method, that starts the whole ball rolling, runs in one thread, called (surprisingly) the main thread. If you looked at the main call stack (and you can, any time you get a stack trace from something that happens after main begins, but not within another thread), you'd see that main() is the first method on the stack the method at the bottom. But as soon as you create a new thread, a new stack materializes and methods called from that thread run in a call stack that's separate from the main() call stack.
</pre>]]></answer>
		</qa>
		<qa id="263" rating="2">			<question><![CDATA[q:What is difference between thread and process?]]></question>
			<answer><![CDATA[<pre>Differences between threads and processes are:-
1. Threads share the address space of the process that  created it; processes have their own address.

2. Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.

3. Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.

4. Threads have almost no overhead; processes have considerable overhead.

5. New threads are easily created; new processes require duplication of the parent process.

6. Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes.

7. Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process do not affect child processes.
</pre>]]></answer>
		</qa>
		<qa id="264" rating="2">			<question><![CDATA[q:What are the two ways of creating thread?]]></question>
			<answer><![CDATA[<pre>There are two ways to create a new thread.

1)Extend the Thread class and override the run() method in your class. Create an instance of the subclass and invoke the start() method on it, which will create a new thread of execution. e.g.

public class NewThread extends Thread{

public void run(){ 
// the code that has to be executed in a separate new thread goes here
} 
public static void main(String [] args){ 
NewThread c = new NewThread(); 
c.start(); 
}

}
2)Implements the Runnable interface.The class will have to implement the run() method in the Runnable interface. Create an instance of this class. Pass the reference of this instance to the Thread constructor a new thread of execution will be created. e.g. class

public class NewThread implements Runnable{

public void run(){ 
// the code that has to be executed in a separate new thread goes here
} 
public static void main(String [] args){ 
NewThread c = new NewThread(); 
Thread t = new Thread(c);
t.start();
}

}
</pre>]]></answer>
		</qa>
		<qa id="265" rating="2">			<question><![CDATA[q:What are the different states of a thread's lifecycle?]]></question>
			<answer><![CDATA[<pre>The different states of threads are as follows:

1) New - When a thread is instantiated it is in New state until the start() method is called on the thread instance. In this state the thread is not considered to be alive. 
2) Runnable - The thread enters into this state after the start method is called in the thread instance. The thread may enter into the Runnable state from Running state. In this state the thread is considered to be alive. 
3) Running - When the thread scheduler picks up the thread from the Runnable thread's pool, the thread starts running and the thread is said to be in Running state.
 4) Waiting/Blocked/Sleeping - In these states the thread is said to be alive but not runnable. The thread switches to this state because of reasons like wait method called or sleep method has been called on the running thread or thread might be waiting for some i/o resource so blocked. 5)      Dead - When the thread finishes its execution i.e. the run() method execution completes, it is said to be in dead state. A dead state can not be started again. If a start() method is invoked on a dead thread a runtime exception will occur.
 </pre>]]></answer>
		</qa>
		<qa id="266" rating="2">			<question><![CDATA[q:  What are three ways in which a thread can enter the waiting state? 
  What are different ways in which a thread can enter the waiting state?]]></question>
			<answer><![CDATA[<pre>A thread can enter the waiting state by the following ways: 
 1. Invoking its sleep() method, 
 2. By blocking on I/O 
 3. By unsuccessfully attempting to acquire an object's lock 
 4. By invoking an object's wait() method. 
 5. It can also enter the waiting state by invoking its (deprecated) suspend() method.
 </pre>]]></answer>
		</qa>
		<qa id="267" rating="2">			<question><![CDATA[q:  What is the difference between yielding and sleeping?]]></question>
			<answer><![CDATA[When a task invokes its yield() method, it returns to the ready state, either from waiting, running or after its creation. When a task invokes its sleep() method, it returns to the waiting state from a running state.]]></answer>
		</qa>
		<qa id="268" rating="2">			<question><![CDATA[q: Extending Thread class or implementing Runnable Interface. Which is better?]]></question>
			<answer><![CDATA[You have two ways to do so. First, making your class "extends" Thread class. The other way is making your class implement "Runnable" interface. The latter is more advantageous, cause when you are going for multiple inheritance, then only interface can help. . If you are already inheriting a different class, then you have to go for Runnable Interface. Otherwise you can extend Thread class. Also, if you are implementing interface, it means you have to implement all methods in the interface. Both Thread class and Runnable interface are provided for convenience and use them as per the requirement. But if you are not extending any class, better extend Thread class as it will save few lines of coding. Otherwise performance wise, there is no distinguishable difference. A thread is in the ready state after it has been created and started.]]></answer>
		</qa>
		<qa id="269" rating="2">			<question><![CDATA[q: What is mutual exclusion? How can you take care of mutual exclusion using Java threads?]]></question>
			<answer><![CDATA[Mutual exclusion is a phenomenon where no two processes can access critical regions of memory at the same time. Using Java multithreading we can arrive at mutual exclusion. For mutual exclusion, you can simply use the synchronized keyword and explicitly or implicitly provide an Object, any Object, to synchronize on. The synchronized keyword can be applied to a class, to a method, or to a block of code. There are several methods in Java used for communicating mutually exclusive threads such as wait( ), notify( ), or notifyAll( ). For example, the notifyAll( ) method wakes up all threads that are in the wait list of an object.]]></answer>
		</qa>
		<qa id="270" rating="2">			<question><![CDATA[q: What is the difference between preemptive scheduling and time slicing?]]></question>
			<answer><![CDATA[Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then re-enters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.]]></answer>
		</qa>
		<qa id="271" rating="2">			<question><![CDATA[q: What invokes a thread's run() method?]]></question>
			<answer><![CDATA[After a thread is started, via its start() method of the Thread class, the JVM invokes the thread's run() method when the thread is initially executed.]]></answer>
		</qa>
		<qa id="272" rating="2">			<question><![CDATA[q: What is the purpose of the wait(), notify(), and notifyAll() methods?]]></question>
			<answer><![CDATA[The wait(), notify() and notifyAll() methods are used to provide an efficient way for thread inter-communication.]]></answer>
		</qa>
		<qa id="273" rating="2">			<question><![CDATA[q: What is thread? What are the high-level thread states? What are the states associated in the thread?]]></question>
			<answer><![CDATA[A thread is an independent path of execution in a system. The high-level thread states are ready, running, waiting and dead.]]></answer>
		</qa>
		<qa id="274" rating="2">			<question><![CDATA[q: What is deadlock?]]></question>
			<answer><![CDATA[When two threads are waiting for each other and can't proceed until the first thread obtains a lock on the other thread or vice versa, the program is said to be in a deadlock.]]></answer>
		</qa>
		<qa id="275" rating="2">			<question><![CDATA[q: How does multithreading take place on a computer with a single CPU?]]></question>
			<answer><![CDATA[The operating system's task scheduler allocates execution time to multiple tasks. By quickly switching between executing tasks, it creates the impression that tasks execute sequentially.]]></answer>
		</qa>
		<qa id="276" rating="2">			<question><![CDATA[q: What are synchronized methods and synchronized statements?]]></question>
			<answer><![CDATA[Synchronized methods are methods that are used to control access to an object. A thread only executes a synchronized method after it has acquired the lock for the method's object or class. Synchronized statements are similar to synchronized methods. A synchronized statement can only be executed after a thread has acquired the lock for the object or class referenced in the synchronized statement.]]></answer>
		</qa>
		<qa id="277" rating="2">			<question><![CDATA[q:What is a volatile keyword?]]></question>
			<answer><![CDATA[In general each thread has its own copy of variable, such that one thread is not concerned with the value of same variable in the other thread. But sometime this may not be the case. Consider a scenario in which the count variable is holding the number of times a method is called for a given class irrespective of any thread calling, in this case irrespective of thread access the count has to be increased so the count variable is declared as volatile. The copy of volatile variable is stored in the main memory, so every time a thread access the variable even for reading purpose the local copy is updated each time from the main memory.	
The volatile variable also have performance issues.]]></answer>
		</qa>
		<qa id="278" rating="2">			<question><![CDATA[q: Can Java object be locked down for exclusive use by a given thread? What happens when a thread cannot acquire a lock on an object?]]></question>
			<answer><![CDATA[Yes. You can lock an object by putting it in a "synchronized" block. The locked object is inaccessible to any thread other than the one that explicitly claimed it. If a thread attempts to execute a synchronized method or synchronized statement and is unable to acquire an object's lock, it enters the waiting state until the lock becomes available.]]></answer>
		</qa>
		<qa id="279" rating="2">			<question><![CDATA[q: What's the difference between the methods sleep() and wait()?]]></question>
			<answer><![CDATA[The sleep method is used when the thread has to be put aside for a fixed amount of time. Ex: sleep(1000), puts the thread aside for exactly one second. The wait method is used to put the thread aside for up to the specified time. It could wait for much lesser time if it receives a notify() or notifyAll() call. Ex: wait(1000), causes a wait of up to one second. The method wait() is defined in the Object and the method sleep() is defined in the class Thread.]]></answer>
		</qa>
		<qa id="280" rating="2">			<question><![CDATA[q: What is the difference between process and thread?]]></question>
			<answer><![CDATA[A thread is a separate path of execution in a program. A Process is a program in execution.]]></answer>
		</qa>
		<qa id="281" rating="2">			<question><![CDATA[q: What is daemon thread and which method is used to create the daemon thread?]]></question>
			<answer><![CDATA[Daemon threads are threads with low priority and runs in the back ground doing the garbage collection operation for the java runtime system. The setDaemon() method is used to create a daemon thread. These threads run without the intervention of the user. To determine if a thread is a daemon thread, use the accessor method isDaemon() 
When a standalone application is run then as long as any user threads are active the JVM cannot terminate, otherwise the JVM terminates along with any daemon threads which might be active. Thus a daemon thread is at the mercy of the runtime system. Daemon threads exist only to serve user threads.]]></answer>
		</qa>
		<qa id="282" rating="2">			<question><![CDATA[q:  What do you understand by Synchronization?]]></question>
			<answer><![CDATA[<pre>With respect to multithreading, Synchronization is a process of controlling the access of shared resources by the multiple threads in such a manner that only one thread can access a particular resource at a time. In non synchronized multithreaded application, it is possible for one thread to modify a shared object while another thread is in the process of using or updating the object's value. Synchronization prevents such type of data corruption which may otherwise lead to dirty reads and significant errors. 
 E.g. synchronizing a function: 
 public synchronized void Method1 () { 
 // method code. 
 } 
 E.g. synchronizing a block of code inside a function: 
 public Method2 (){ 
 synchronized (this) { 
 // synchronized code here. 
 } 
 }</pre>]]></answer>
		</qa>
		<qa id="283" rating="2">			<question><![CDATA[q:  When  will you synchronize a piece of your code?]]></question>
			<answer><![CDATA[When you expect that your shared code will be accessed by different threads and these threads may change a particular data causing data corruption, then they are placed in a synchronized construct or a synchronized method.]]></answer>
		</qa>
		<qa id="284" rating="2">			<question><![CDATA[q:  Why would you use a synchronized block vs. synchronized method?]]></question>
			<answer><![CDATA[Synchronized blocks place locks for shorter periods than synchronized methods.]]></answer>
		</qa>
		<qa id="285" rating="An object's lock is a mechanism that is used by multiple threads to obtain synchronized access to the object. A thread may execute a synchronized method of an object only after it has acquired the object's lock. All objects and classes have locks. A class's lock is acquired on the class's Class object. 
r:2">			<question><![CDATA[q:  What is an object's lock and which objects have locks?]]></question>
			<answer><![CDATA[Answe]]></answer>
		</qa>
		<qa id="286" rating="2">			<question><![CDATA[q:  Can a lock be acquired on a class?]]></question>
			<answer><![CDATA[Yes, a lock can be acquired on a class. This lock is acquired on the class's Class object.]]></answer>
		</qa>
		<qa id="287" rating="2">			<question><![CDATA[q:  What state does a thread enter when it terminates its processing?]]></question>
			<answer><![CDATA[When a thread terminates its processing, it enters the dead state.]]></answer>
		</qa>
		<qa id="288" rating="2">			<question><![CDATA[q:  How would you implement a thread pool?]]></question>
			<answer><![CDATA[<pre>public class ThreadPool implements ThreadPoolInt 
  This class is an generic implementation of a thread pool, which takes the following input 
  a) Size of the pool to be constructed 
  b) Name of the class which implements Runnable and constructs a thread pool with active threads that are waiting for activation. Once the threads have finished processing they come back and wait once again in the pool. 
This thread pool engine can be locked i.e. if some internal operation is performed on the pool then it is preferable that the thread engine be locked. Locking ensures that no new threads are issued by the engine. However, the currently executing threads are allowed to continue till they come back to the passivePool. 
</pre>]]></answer>
		</qa>
		<qa id="289" rating="2">			<question><![CDATA[q: Is there a separate stack for each thread in Java?]]></question>
			<answer><![CDATA[Yes. Every thread maintains its own separate stack, called Runtime Stack but they share the same memory. Elements of the stack are the method invocations, 
 called activation records or stack frame. The activation record contains pertinent information about a method like local variables.]]></answer>
		</qa>
		<qa id="290" rating="3">			<question><![CDATA[q:What is the difference between yield() and sleep()?]]></question>
			<answer><![CDATA[<pre>yield() allows the current the thread to release its lock from the object and scheduler gives the lock of the object to the other thread with same priority.
  sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn't release the lock.</pre>]]></answer>
		</qa>
		<qa id="291" rating="3">			<question><![CDATA[q:What is the difference between wait() and sleep()?]]></question>
			<answer><![CDATA[<pre>
1) wait() is a method of Object class. sleep() is a method of Object class.

2) sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn't release the lock. wait() allows thread to release the lock and goes to suspended state. The thread is only active when a notify() or notifAll() method is called for the same object.
</pre>]]></answer>
		</qa>
		<qa id="292" rating="2">			<question><![CDATA[q:What is difference between notify() and notfiyAll()?]]></question>
			<answer><![CDATA[notify( ) wakes up the first thread that called wait( ) on the same object. 
notifyAll( ) wakes up all the threads that called wait( ) on the same object. The 
highest priority thread will run first]]></answer>
		</qa>
		<qa id="293" rating="2">			<question><![CDATA[q:If a thread goes to sleep does it hold the lock?]]></question>
			<answer><![CDATA[Yes when a thread goes to sleep it does not release the lock.]]></answer>
		</qa>
		<qa id="294" rating="2">			<question><![CDATA[q:Can a thread hold multiple locks at the same time?]]></question>
			<answer><![CDATA[Yes. A thread can hold multiple locks at the same time. Once a thread acquires a lock and enters into the synchronized method / block, it may call another synchronized method and acquire a lock on another object.]]></answer>
		</qa>
		<qa id="295" rating="2">			<question><![CDATA[q:Can a thread call multiple synchronized methods on the object of which it hold the lock?]]></question>
			<answer><![CDATA[Yes. Once a thread acquires a lock in some object, it may call any other synchronized method of that same object using the lock that it already holds.]]></answer>
		</qa>
		<qa id="296" rating="2">			<question><![CDATA[q:Can static methods be synchronized?]]></question>
			<answer><![CDATA[Yes. As static methods are class methods and have only one copy of static data for the class, only one lock for the entire class is required. Every class in java is represented by java.lang.Class instance. The lock on this instance is used to synchronize the static methods.]]></answer>
		</qa>
		<qa id="297" rating="2">			<question><![CDATA[q:Can two threads call two different static synchronized methods of the same class?]]></question>
			<answer><![CDATA[No. The static synchronized methods of the same class always block each other as only one lock per class exists. So no two static synchronized methods can execute at the same time.]]></answer>
		</qa>
		<qa id="298" rating="2">			<question><![CDATA[q:Does a static synchronized method block a non-static synchronized method?]]></question>
			<answer><![CDATA[No As the thread executing the static synchronized method holds a lock on the class and the thread executing the non-satic synchronized method holds the lock on the object on which the method has been called, these two locks are different and these threads do not block each other.]]></answer>
		</qa>
		<qa id="299" rating="2">			<question><![CDATA[q:Once a thread has been started can it be started again?]]></question>
			<answer><![CDATA[No. Only a thread can be started only once in its lifetime. If you try starting a thread which has been already started once an IllegalThreadStateException is thrown, which is a runtime exception. A thread in runnable state or a dead thread can not be restarted.]]></answer>
		</qa>
		<qa id="300" rating="2">			<question><![CDATA[q:When does deadlock occur and how to avoid it?]]></question>
			<answer><![CDATA[When a locked object tries to access a locked object which is trying to access the first locked object. When the threads are waiting for each other to release the lock on a particular object, deadlock occurs .]]></answer>
		</qa>
		<qa id="301" rating="2">			<question><![CDATA[q:What is a better way of creating multithreaded application? Extending Thread class or implementing Runnable?]]></question>
			<answer><![CDATA[If a class is made to extend the thread class to have a multithreaded application then this subclass of Thread can not extend any other class and the required application will have to be added to this class as it can not be inherited from any other class. If a class is made to implement Runnable interface, then the class can extend other class or implement other interface.]]></answer>
		</qa>
		<qa id="302" rating="3">			<question><![CDATA[q:Can the start() method of the Thread class be overridden? If yes should it be overridden?]]></question>
			<answer><![CDATA[Yes the start() method can be overridden. But it should not be overridden as its implementation in thread class has the code to create a new executable thread and is specialised.]]></answer>
		</qa>
		<qa id="303" rating="2">			<question><![CDATA[q:What are the methods of the thread class used to schedule the threads?]]></question>
			<answer><![CDATA[<pre>The methods are as follows:

public static void sleep(long millis) throws InterruptedException 
public static void yield()
public final void join() throws InterruptedException 
public final void setPriority(int priority) 
public final void wait() throws InterruptedException 
public final void notify() 
public final void notifyAll()
</pre>]]></answer>
		</qa>
		<qa id="304" rating="2">			<question><![CDATA[q:Which thread related methods are available in Object class?]]></question>
			<answer><![CDATA[<pre>The methods are:

public final void wait() throws Interrupted exception
public final void notify()
public final void notifyAll()
</pre>]]></answer>
		</qa>
		<qa id="305" rating="2">			<question><![CDATA[q:Which thread related methods are available in Thread class?]]></question>
			<answer><![CDATA[<pre>Methods which are mainly used :

public static void sleep(long millis) throws Interrupted exception 
public static void yield() public final void join() throws Interrupted exception
public final void setPriority(int priority) 
public void start()
public void interrupt()
public final void join()
public void run()
public void resume()
</pre>]]></answer>
		</qa>
		<qa id="306" rating="2">			<question><![CDATA[q:List the methods which when called the thread does not release the locks held?]]></question>
			<answer><![CDATA[<pre>Following are the methods.

notify()
join()
sleep()
yield()</pre>]]></answer>
		</qa>
		<qa id="307" rating="2">			<question><![CDATA[q:List the methods which when called on the object the thread releases the locks held on that object?]]></question>
			<answer><![CDATA[wait()]]></answer>
		</qa>
		<qa id="308" rating="3">			<question><![CDATA[q:Does each thread has its own thread stack?]]></question>
			<answer><![CDATA[<pre>Yes each thread has its own call stack. For eg

Thread t1 = new Thread();
Thread t2 = new Thread();
Thread t3 = t1;
In the above example t1 and t3 will have the same stack and t2 will have its own independent stack.
</pre>]]></answer>
		</qa>
		<qa id="309" rating="3">			<question><![CDATA[q:What is thread starvation?]]></question>
			<answer><![CDATA[In a multi-threaded environment thread starvation occurs if a low priority thread is not able to run or get a lock on the resoruce because of presence of many high priority threads. This is mainly possible by setting thread priorities inappropriately.]]></answer>
		</qa>
		<qa id="310" rating="3">			<question><![CDATA[q:What is threadLocal variable?]]></question>
			<answer><![CDATA[<pre>ThreadLocal is a class. If a variable is declared as threadLocal then each thread will have a its own copy of variable and would not interfere with the other's thread copy. Typical scenario to use this would be giving JDBc connection to each thread so that there is no conflict.

ThreadLocal class by JAVA API
public class ThreadLocal { 
  public Object get();
  public void set(Object newValue);
  public Object initialValue();
}


Implementation of ThreadLocal
public class ConnectionDispenser { 
  private static class ThreadLocalConnection extends ThreadLocal { 
    public Object initialValue() { 
      return DriverManager.getConnection(ConfigurationSingleton.getDbUrl()); 
    } 
  } 

  private static ThreadLocalConnection conn = new ThreadLocalConnection(); 

    public static Connection getConnection() { 
      return (Connection) conn.get(); 
    } 
  } 
  </pre>]]></answer>
		</qa>
	</category>
</questionbank>
